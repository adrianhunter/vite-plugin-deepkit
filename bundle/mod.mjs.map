{"version":3,"sources":["../mod.mts","../type-compiler/src/compiler.ts","../type-compiler/src/reflection-ast.ts","../type-spec/src/type.ts","../type-compiler/src/resolver.ts"],"sourcesContent":["import { createFilter } from \"@rollup/pluginutils\";\nimport ts from \"typescript\";\nimport { transformer, declarationTransformer } from \"./type-compiler/src/compiler\";\nimport type {Plugin} from \"vite\"\nexport interface Options {\n  test?: RegExp;\n  include?: string;\n  exclude?: string;\n  transformers?: ts.CustomTransformers\n}\nexport { transformer, declarationTransformer }\n\nexport function deepkitType(options: Options = {}): Plugin {\n  const filter = createFilter(options.include ?? \"**/*.ts\", options.exclude ?? \"node_modules/**\");\n  const transformers = options.transformers || {\n    before: [transformer],\n    after: [declarationTransformer],\n  }\n  return {\n    name: \"deepkit-type\",\n    enforce: \"pre\",\n    transform(code: string, fileName: string) {\n      if (!filter(fileName)) return null;\n      const transformed = ts.transpileModule(code, {\n        \"compilerOptions\": {\n          \"target\": ts.ScriptTarget.ESNext,\n          \"module\": ts.ModuleKind.ESNext\n        },\n        fileName,\n        //@ts-ignore\n        transformers\n      });\n\n      return {\n        code: transformed.outputText,\n        map: transformed.sourceMapText,\n      };\n    },\n  };\n}\n","/*\n * Deepkit Framework\n * Copyright (c) Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nimport type {\n    __String,\n    ArrayTypeNode,\n    ArrowFunction,\n    Bundle,\n    CallSignatureDeclaration,\n    ClassDeclaration,\n    ClassElement,\n    ClassExpression,\n    CompilerHost,\n    CompilerOptions,\n    ConditionalTypeNode,\n    ConstructorDeclaration,\n    ConstructorTypeNode,\n    ConstructSignatureDeclaration,\n    CustomTransformer,\n    CustomTransformerFactory,\n    Declaration,\n    EntityName,\n    EnumDeclaration,\n    ExportDeclaration,\n    Expression,\n    ExpressionWithTypeArguments,\n    FunctionDeclaration,\n    FunctionExpression,\n    FunctionTypeNode,\n    Identifier,\n    ImportDeclaration,\n    IndexedAccessTypeNode,\n    IndexSignatureDeclaration,\n    InferTypeNode,\n    InterfaceDeclaration,\n    IntersectionTypeNode,\n    LiteralTypeNode,\n    MappedTypeNode,\n    MethodDeclaration,\n    MethodSignature,\n    Modifier,\n    ModuleDeclaration,\n    Node,\n    NodeFactory,\n    PropertyAccessExpression,\n    PropertyDeclaration,\n    PropertySignature,\n    QualifiedName,\n    RestTypeNode,\n    SignatureDeclaration,\n    Statement,\n    TemplateLiteralTypeNode,\n    TransformationContext,\n    TupleTypeNode,\n    TypeAliasDeclaration,\n    TypeChecker,\n    TypeLiteralNode,\n    TypeNode,\n    TypeOperatorNode,\n    TypeParameterDeclaration,\n    TypeQueryNode,\n    TypeReferenceNode,\n    UnionTypeNode,\n    ParseConfigHost,\n    TsConfigSourceFile,\n    TransformerFactory,\n} from 'typescript';\nimport ts from 'typescript';\n\nimport {\n    ensureImportIsEmitted,\n    extractJSDocAttribute,\n    getGlobalsOfSourceFile,\n    getIdentifierName,\n    getNameAsString,\n    getPropertyName,\n    hasModifier,\n    isNodeWithLocals,\n    NodeConverter,\n    PackExpression,\n    serializeEntityNameAsExpression,\n} from './reflection-ast.js';\nimport { SourceFile } from './ts-types.js';\nimport { existsSync, readFileSync } from 'node:fs';\nimport { dirname, isAbsolute, join, resolve } from 'node:path';\nimport stripJsonComments from 'strip-json-comments';\nimport { MappedModifier, ReflectionOp, TypeNumberBrand } from '../../type-spec/src/type.js';\nimport { Resolver } from './resolver.js';\nimport { knownLibFilesForCompilerOptions } from '@typescript/vfs';\nimport mm from 'micromatch';\nconst contains = mm.contains\nimport { isObject } from '@deepkit/core';\n\nconst {\n    visitEachChild,\n    visitNode,\n    isArrayTypeNode,\n    isArrowFunction,\n    isCallExpression,\n    isCallSignatureDeclaration,\n    isClassDeclaration,\n    isClassExpression,\n    isConstructorDeclaration,\n    isConstructorTypeNode,\n    isConstructSignatureDeclaration,\n    isEnumDeclaration,\n    isExportDeclaration,\n    isExpressionWithTypeArguments,\n    isFunctionDeclaration,\n    isFunctionExpression,\n    isFunctionLike,\n    isIdentifier,\n    isImportClause,\n    isImportDeclaration,\n    isImportSpecifier,\n    isInferTypeNode,\n    isInterfaceDeclaration,\n    isMethodDeclaration,\n    isMethodSignature,\n    isModuleDeclaration,\n    isNamedExports,\n    isNamedTupleMember,\n    isNewExpression,\n    isObjectLiteralExpression,\n    isOptionalTypeNode,\n    isParameter,\n    isParenthesizedExpression,\n    isParenthesizedTypeNode,\n    isPropertyAccessExpression,\n    isQualifiedName,\n    isSourceFile,\n    isStringLiteral,\n    isTypeAliasDeclaration,\n    isTypeParameterDeclaration,\n    isTypeQueryNode,\n    isTypeReferenceNode,\n    isUnionTypeNode,\n    isVariableDeclaration,\n    getEffectiveConstraintOfTypeParameter,\n    getJSDocTags,\n    addSyntheticLeadingComment,\n    createCompilerHost,\n    createPrinter,\n    escapeLeadingUnderscores,\n    EmitHint,\n    NodeFlags,\n    SyntaxKind,\n    ModuleKind,\n    ScriptTarget,\n    ModifierFlags,\n    ScriptKind,\n} = ts;\n\nexport function encodeOps(ops: ReflectionOp[]): string {\n    return ops.map(v => String.fromCharCode(v + 33)).join('');\n}\n\nfunction debug(...message: any[]): void {\n    if ('undefined' !== typeof process && 'string' === typeof process.env.DEBUG && process.env.DEBUG.includes('deepkit')) {\n        console.debug(...message);\n    }\n}\n\nexport const packSizeByte: number = 6;\n\nconst serverEnv = 'undefined' !== typeof process;\n\n/**\n * It can't be more ops than this given number\n */\nexport const packSize: number = 2 ** packSizeByte; //64\nconst reflectionModes = ['always', 'default', 'never'] as const;\n\ninterface ReflectionOptions {\n    /**\n     * Allows to exclude type definitions/TS files from being included in the type compilation step.\n     * When a global .d.ts is matched, their types won't be embedded (useful to exclude DOM for example)\n     */\n    exclude?: string[];\n}\n\ninterface ReflectionConfig {\n    mode: typeof reflectionModes[number];\n    options: ReflectionOptions;\n    /**\n     * Paths in exclude are relative to this baseDir\n     */\n    baseDir?: string;\n}\n\nconst OPs: { [op in ReflectionOp]?: { params: number } } = {\n    [ReflectionOp.literal]: { params: 1 },\n    // [ReflectionOp.pointer]: { params: 1 },\n    // [ReflectionOp.arg]: { params: 1 },\n    [ReflectionOp.classReference]: { params: 1 },\n    [ReflectionOp.propertySignature]: { params: 1 },\n    [ReflectionOp.property]: { params: 1 },\n    [ReflectionOp.jump]: { params: 1 },\n    [ReflectionOp.enum]: { params: 0 },\n    [ReflectionOp.enumMember]: { params: 1 },\n    [ReflectionOp.typeParameter]: { params: 1 },\n    [ReflectionOp.typeParameterDefault]: { params: 1 },\n    [ReflectionOp.mappedType]: { params: 2 },\n    [ReflectionOp.call]: { params: 1 },\n    [ReflectionOp.inline]: { params: 1 },\n    [ReflectionOp.inlineCall]: { params: 2 },\n    [ReflectionOp.loads]: { params: 2 },\n    [ReflectionOp.infer]: { params: 2 },\n    [ReflectionOp.defaultValue]: { params: 1 },\n    [ReflectionOp.parameter]: { params: 1 },\n    [ReflectionOp.method]: { params: 1 },\n    [ReflectionOp.description]: { params: 1 },\n    [ReflectionOp.numberBrand]: { params: 1 },\n    [ReflectionOp.typeof]: { params: 1 },\n    [ReflectionOp.classExtends]: { params: 1 },\n    [ReflectionOp.distribute]: { params: 1 },\n    [ReflectionOp.jumpCondition]: { params: 2 },\n};\n\nexport function debugPackStruct(sourceFile: SourceFile, forType: Node, pack: { ops: ReflectionOp[], stack: PackExpression[] }): void {\n    const items: any[] = [];\n\n    for (let i = 0; i < pack.ops.length; i++) {\n        const op = pack.ops[i];\n        const opInfo = OPs[op];\n        items.push(ReflectionOp[op]);\n        if (opInfo && opInfo.params > 0) {\n            for (let j = 0; j < opInfo.params; j++) {\n                const address = pack.ops[++i];\n                items.push(address);\n            }\n        }\n    }\n\n    const printer = createPrinter();\n    const stack: any[] = [];\n    for (const s of pack.stack) {\n        if ('object' === typeof s && 'getText' in s) {\n            stack.push(printer.printNode(EmitHint.Unspecified, s, sourceFile));\n        } else {\n            stack.push(s);\n        }\n    }\n    // console.log('debugPackStruct:', 'getText' in forType ? forType.getText().replace(/\\n/g, '') : 'no node'); //printer.printNode(EmitHint.Unspecified, forType, sourceFile).replace(/\\n/g, ''));\n    console.log(stack.join(','), '|', ...items);\n}\n\ninterface Frame {\n    variables: { name: string, index: number }[],\n    opIndex: number;\n    conditional?: true;\n    previous?: Frame;\n}\n\nfunction findVariable(frame: Frame, name: string, frameOffset: number = 0): { frameOffset: number, stackIndex: number } | undefined {\n    const variable = frame.variables.find(v => v.name === name);\n    if (variable) {\n        return { frameOffset, stackIndex: variable.index };\n    }\n\n    if (frame.previous) return findVariable(frame.previous, name, frameOffset + 1);\n\n    return;\n}\n\nfunction findConditionalFrame(frame: Frame): Frame | undefined {\n    if (frame.conditional) return frame;\n    if (frame.previous) return findConditionalFrame(frame.previous);\n\n    return;\n}\n\nfunction findSourceFile(node: Node): SourceFile | undefined {\n    if (node.kind === SyntaxKind.SourceFile) return node as SourceFile;\n    let current = node.parent;\n    while (current && current.kind !== SyntaxKind.SourceFile) {\n        current = current.parent;\n    }\n    return current as SourceFile;\n}\n\ntype StackEntry = Expression | string | number | boolean;\n\nclass CompilerProgram {\n    protected ops: ReflectionOp[] = [];\n    protected stack: StackEntry[] = [];\n    protected mainOffset: number = 0;\n\n    protected stackPosition: number = 0;\n\n    protected frame: Frame = { variables: [], opIndex: 0 };\n\n    protected activeCoRoutines: { ops: ReflectionOp[] }[] = [];\n    protected coRoutines: { ops: ReflectionOp[] }[] = [];\n\n    constructor(public forNode: Node, public sourceFile: SourceFile) {\n    }\n\n    buildPackStruct() {\n        const ops: ReflectionOp[] = [...this.ops];\n\n        if (this.coRoutines.length) {\n            for (let i = this.coRoutines.length - 1; i >= 0; i--) {\n                ops.unshift(...this.coRoutines[i].ops);\n            }\n        }\n\n        if (this.mainOffset) {\n            ops.unshift(ReflectionOp.jump, this.mainOffset);\n        }\n\n        return { ops, stack: this.stack };\n    }\n\n    isEmpty(): boolean {\n        return this.ops.length === 0;\n    }\n\n    pushConditionalFrame(): void {\n        const frame = this.pushFrame();\n        frame.conditional = true;\n    }\n\n    pushStack(item: StackEntry): number {\n        this.stack.push(item);\n        return this.stackPosition++;\n    }\n\n    pushCoRoutine(): void {\n        this.pushFrame(true); //co-routines have implicit stack frames due to call convention\n        this.activeCoRoutines.push({ ops: [] });\n    }\n\n    popCoRoutine(): number {\n        const coRoutine = this.activeCoRoutines.pop();\n        if (!coRoutine) throw new Error('No active co routine found');\n        this.popFrameImplicit();\n        if (this.mainOffset === 0) {\n            this.mainOffset = 2; //we add JUMP + index when building the program\n        }\n        const startIndex = this.mainOffset;\n        coRoutine.ops.push(ReflectionOp.return);\n        this.coRoutines.push(coRoutine);\n        this.mainOffset += coRoutine.ops.length;\n        return startIndex;\n    }\n\n    pushOp(...ops: ReflectionOp[]): void {\n        for (const op of ops) {\n            if ('number' !== typeof op) {\n                throw new Error('No valid OP added');\n            }\n            // if (op + 33 > 126) {\n            //todo: encode as var int\n            // throw new Error('stack pointer too big ' + op);\n            // }\n        }\n        if (this.activeCoRoutines.length) {\n            this.activeCoRoutines[this.activeCoRoutines.length - 1].ops.push(...ops);\n            return;\n        }\n\n        this.ops.push(...ops);\n    }\n\n    pushOpAtFrame(frame: Frame, ...ops: ReflectionOp[]): void {\n        if (this.activeCoRoutines.length) {\n            this.activeCoRoutines[this.activeCoRoutines.length - 1].ops.splice(frame.opIndex, 0, ...ops);\n            return;\n        }\n\n        this.ops.splice(frame.opIndex, 0, ...ops);\n    }\n\n    /**\n     * Returns the index of the `entry` in the stack, if already exists. If not, add it, and return that new index.\n     */\n    findOrAddStackEntry(entry: any): number {\n        const index = this.stack.indexOf(entry);\n        if (index !== -1) return index;\n        return this.pushStack(entry);\n    }\n\n    /**\n     * To make room for a stack entry expected on the stack as input for example.\n     */\n    increaseStackPosition(): number {\n        return this.stackPosition++;\n    }\n\n    protected resolveFunctionParameters = new Map<Node, number>();\n\n    resolveFunctionParametersIncrease(fn: Node) {\n        this.resolveFunctionParameters.set(fn, (this.resolveFunctionParameters.get(fn) || 0) + 1);\n    }\n\n    resolveFunctionParametersDecrease(fn: Node) {\n        this.resolveFunctionParameters.set(fn, (this.resolveFunctionParameters.get(fn) || 1) - 1);\n    }\n\n    isResolveFunctionParameters(fn: Node) {\n        return (this.resolveFunctionParameters.get(fn) || 0) > 0;\n    }\n\n    /**\n     *\n     * Each pushFrame() call needs a popFrame() call.\n     */\n    pushFrame(implicit: boolean = false) {\n        if (!implicit) this.pushOp(ReflectionOp.frame);\n        const opIndex = this.activeCoRoutines.length ? this.activeCoRoutines[this.activeCoRoutines.length - 1].ops.length : this.ops.length;\n        this.frame = { previous: this.frame, variables: [], opIndex };\n        return this.frame;\n    }\n\n    findConditionalFrame() {\n        return findConditionalFrame(this.frame);\n    }\n\n    /**\n     * Remove stack without doing it as OP in the processor. Some other command calls popFrame() already, which makes popFrameImplicit() an implicit popFrame.\n     * e.g. union, class, etc. all call popFrame(). the current CompilerProgram needs to be aware of that, which this function is for.\n     */\n    popFrameImplicit() {\n        if (this.frame.previous) this.frame = this.frame.previous;\n    }\n\n    moveFrame() {\n        this.pushOp(ReflectionOp.moveFrame);\n        if (this.frame.previous) this.frame = this.frame.previous;\n    }\n\n    pushVariable(name: string, frame: Frame = this.frame): number {\n        this.pushOpAtFrame(frame, ReflectionOp.var);\n        frame.variables.push({\n            index: frame.variables.length,\n            name,\n        });\n        return frame.variables.length - 1;\n    }\n\n    pushTemplateParameter(name: string, withDefault: boolean = false): number {\n        this.pushOp(withDefault ? ReflectionOp.typeParameterDefault : ReflectionOp.typeParameter, this.findOrAddStackEntry(name));\n        this.frame.variables.push({\n            index: this.frame.variables.length,\n            name,\n        });\n        return this.frame.variables.length - 1;\n    }\n\n    findVariable(name: string, frame = this.frame) {\n        return findVariable(frame, name);\n    }\n}\n\nfunction getAssignTypeExpression(call: Expression): Expression | undefined {\n    if (isParenthesizedExpression(call) && isCallExpression(call.expression)) {\n        call = call.expression;\n    }\n\n    if (isCallExpression(call) && isIdentifier(call.expression) && getIdentifierName(call.expression) === '__assignType' && call.arguments.length > 0) {\n        return call.arguments[0];\n    }\n\n    return;\n}\n\nfunction getReceiveTypeParameter(type: TypeNode): TypeReferenceNode | undefined {\n    if (isUnionTypeNode(type)) {\n        for (const t of type.types) {\n            const rfn = getReceiveTypeParameter(t);\n            if (rfn) return rfn;\n        }\n    } else if (isTypeReferenceNode(type) && isIdentifier(type.typeName)\n        && getIdentifierName(type.typeName) === 'ReceiveType' && !!type.typeArguments\n        && type.typeArguments.length === 1) return type;\n\n    return;\n}\n\n/**\n * Read the TypeScript AST and generate pack struct (instructions + pre-defined stack).\n *\n * This transformer extracts type and add the encoded (so its small and low overhead) at classes and functions as property.\n *\n * Deepkit/type can then extract and decode them on-demand.\n */\nexport class ReflectionTransformer implements CustomTransformer {\n    sourceFile!: SourceFile;\n    protected f: NodeFactory;\n    protected currentReflectionConfig: ReflectionConfig = { mode: 'never', options: {} };\n\n    public defaultExcluded: string[] = [\n        'lib.dom.d.ts',\n        'lib.dom.iterable.d.ts',\n        'lib.es2017.typedarrays.d.ts',\n    ];\n\n    protected embedAssignType: boolean = false;\n\n    protected reflectionMode?: typeof reflectionModes[number];\n    protected reflectionOptions?: ReflectionOptions;\n\n    /**\n     * Types added to this map will get a type program directly under it.\n     * This is for types used in the very same file.\n     */\n    protected compileDeclarations = new Map<TypeAliasDeclaration | InterfaceDeclaration | EnumDeclaration, { name: EntityName, sourceFile: SourceFile, compiled?: Statement[] }>();\n\n    /**\n     * Types added to this map will get a type program at the top root level of the program.\n     * This is for imported types, which need to be inlined into the current file, as we do not emit type imports (TS will omit them).\n     */\n    protected embedDeclarations = new Map<Node, { name: EntityName, sourceFile: SourceFile }>();\n\n    /**\n     * When a node was embedded or compiled (from the maps above), we store it here to know to not add it again.\n     */\n    protected compiledDeclarations = new Set<Node>();\n\n    protected addImports: { from: Expression, identifier: Identifier }[] = [];\n\n    protected nodeConverter: NodeConverter;\n    protected typeChecker?: TypeChecker;\n    protected resolver: Resolver;\n    protected host: CompilerHost;\n    protected overriddenHost = false;\n\n    protected compilerOptions: CompilerOptions;\n\n    /**\n     * When a deep call expression was found a script-wide variable is necessary\n     * as temporary storage.\n     */\n    protected tempResultIdentifier?: Identifier;\n    protected parseConfigHost?: ParseConfigHost;\n\n    protected config: { compilerOptions: ts.CompilerOptions, extends?: string, reflectionOptions?: ReflectionOptions, reflection?: string | string[] } = { compilerOptions: {} };\n\n    constructor(\n        protected context: TransformationContext,\n    ) {\n        this.f = context.factory;\n        this.nodeConverter = new NodeConverter(this.f);\n        this.compilerOptions = context.getCompilerOptions();\n        this.host = createCompilerHost(this.compilerOptions);\n        this.resolver = new Resolver(this.compilerOptions, this.host);\n    }\n\n    forHost(host: CompilerHost): this {\n        this.host = host;\n        this.resolver.host = host;\n        this.overriddenHost = true;\n        return this;\n    }\n\n    withReflectionMode(mode: typeof reflectionModes[number], options?: ReflectionOptions): this {\n        this.reflectionMode = mode;\n        this.reflectionOptions = options;\n        return this;\n    }\n\n    transformBundle(node: Bundle): Bundle {\n        return node;\n    }\n\n    getTempResultIdentifier(): Identifier {\n        if (this.tempResultIdentifier) return this.tempResultIdentifier;\n\n        const locals = isNodeWithLocals(this.sourceFile) ? this.sourceFile.locals : undefined;\n\n        if (locals) {\n            let found = 'Ωr';\n            for (let i = 0; ; i++) {\n                found = 'Ωr' + (i ? i : '');\n                if (!locals.has(escapeLeadingUnderscores(found))) break;\n            }\n            this.tempResultIdentifier = this.f.createIdentifier(found);\n        } else {\n            this.tempResultIdentifier = this.f.createIdentifier('Ωr');\n        }\n        return this.tempResultIdentifier;\n    }\n\n    readTsConfig(path: string) {\n        if (!this.parseConfigHost) {\n            this.parseConfigHost = {\n                useCaseSensitiveFileNames: true,\n                fileExists: (path: string) => this.host.fileExists(path),\n                readFile: (path: string) => this.host.readFile(path),\n                readDirectory: (path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number) => {\n                    if (!this.host.readDirectory) return [];\n                    return this.host.readDirectory(path, extensions || [], exclude, include || [], depth)\n                },\n            };\n        }\n\n        const configFile = ts.readConfigFile(path, (path: string) => this.host.readFile(path));\n        if (configFile.error) {\n            debug(`Failed to read tsconfig ${path}: ${configFile.error.messageText}`);\n            return;\n        }\n\n        const parsed = ts.parseJsonConfigFileContent(configFile.config, this.parseConfigHost, dirname(path));\n        if (parsed.errors.length) {\n            debug(`Failed to parse tsconfig ${path}: ${parsed.errors.map(v => v.messageText).join(', ')}`);\n            return;\n        }\n\n        return Object.assign(configFile.config, { compilerOptions: parsed.options });\n    }\n\n    transformSourceFile(sourceFile: SourceFile): SourceFile {\n        this.sourceFile = sourceFile;\n\n        //if it's not a TS/TSX file, we do not transform it\n        if (sourceFile.scriptKind !== ScriptKind.TS && sourceFile.scriptKind !== ScriptKind.TSX) return sourceFile;\n\n        if ((sourceFile as any).deepkitTransformed) return sourceFile;\n        (sourceFile as any).deepkitTransformed = true;\n        this.embedAssignType = false;\n\n        //some builder do not provide the full compiler options (e.g. webpack in nx),\n        //so we need to load the file manually and apply what we need.\n        if ('string' === typeof this.compilerOptions.configFilePath) {\n            const configFile = this.readTsConfig(this.compilerOptions.configFilePath);\n            if (configFile) {\n                this.config = Object.assign({ compilerOptions: {} }, configFile);\n                this.compilerOptions = Object.assign(this.config.compilerOptions, this.compilerOptions);\n            }\n        } else {\n            //find tsconfig via sourceFile.fileName\n            const configPath = ts.findConfigFile(dirname(sourceFile.fileName), (path) => this.host.fileExists(path));\n            if (configPath) {\n                const configFile = this.readTsConfig(configPath);\n                if (configFile) {\n                    this.config = Object.assign({ compilerOptions: {} }, configFile);\n                    this.compilerOptions = Object.assign(this.config.compilerOptions, this.compilerOptions);\n                    this.compilerOptions.configFilePath = configPath;\n                }\n            }\n        }\n        if (!this.overriddenHost) {\n            this.host = createCompilerHost(this.compilerOptions);\n            this.resolver = new Resolver(this.compilerOptions, this.host);\n        }\n\n        this.addImports = [];\n\n        //iterate through all configs (this.config.extends) until we have all reflection options found.\n        let currentConfig = this.config;\n        let basePath = this.config.compilerOptions.configFilePath as string;\n        if (basePath) {\n            basePath = dirname(basePath);\n            if (!this.reflectionMode && currentConfig.reflection !== undefined) this.reflectionMode = this.parseReflectionMode(currentConfig.reflection, basePath);\n            if (!this.compilerOptions && currentConfig.reflectionOptions !== undefined) this.reflectionOptions = this.parseReflectionOptionsDefaults(currentConfig.reflectionOptions);\n            while ((this.reflectionMode === undefined || this.compilerOptions === undefined) && 'string' === typeof basePath && currentConfig.extends) {\n                const path = join(basePath, currentConfig.extends);\n                const nextConfig = ts.readConfigFile(path, (path: string) => this.host.readFile(path));\n                if (!nextConfig) break;\n                if (!this.reflectionMode && nextConfig.config.reflection !== undefined) this.reflectionMode = this.parseReflectionMode(nextConfig.config.reflection, basePath);\n                if (!this.reflectionOptions && nextConfig.config.reflectionOptions !== undefined) this.reflectionOptions = this.parseReflectionOptionsDefaults(nextConfig.config.reflectionOptions);\n                currentConfig = Object.assign({}, nextConfig.config);\n                basePath = dirname(path);\n            }\n        }\n\n        debug(`Transform file ${sourceFile.fileName} via config ${this.compilerOptions.configFilePath || 'none'}, reflection=${this.reflectionMode}.`);\n\n        if (this.reflectionMode === 'never') {\n            return sourceFile;\n        }\n\n        if (!(sourceFile as any).locals) {\n            //@ts-ignore\n            ts.bindSourceFile(sourceFile, this.compilerOptions);\n        }\n\n        if (sourceFile.kind !== SyntaxKind.SourceFile) {\n            // const path = require.resolve('typescript');\n            throw new Error(`Invalid TypeScript library imported. SyntaxKind different ${sourceFile.kind} !== ${SyntaxKind.SourceFile}. typescript package path: ${\"todo...\"}`);\n        }\n\n        const visitor = (node: Node): any => {\n            node = visitEachChild(node, visitor, this.context);\n\n            if ((isInterfaceDeclaration(node) || isTypeAliasDeclaration(node) || isEnumDeclaration(node))) {\n                const reflection = this.findReflectionConfig(node);\n\n                if (reflection.mode !== 'never') {\n                    this.compileDeclarations.set(node, {\n                        name: node.name,\n                        sourceFile: this.sourceFile\n                    });\n                }\n            }\n\n            if (isMethodDeclaration(node) && node.parent && node.body && isObjectLiteralExpression(node.parent)) {\n                //replace MethodDeclaration with MethodExpression\n                // {add(v: number) {}} => {add: function (v: number) {}}\n                //so that __type can be added.\n                //{default(){}} can not be converted without losing the function name, so we skip that for the moment.\n                let valid = true;\n                if (node.name.kind === SyntaxKind.Identifier && getIdentifierName(node.name) === 'default') valid = false;\n                if (valid) {\n                    const method = this.decorateFunctionExpression(\n                        this.f.createFunctionExpression(\n                            node.modifiers as ReadonlyArray<Modifier>, node.asteriskToken, isIdentifier(node.name) ? node.name : undefined,\n                            node.typeParameters, node.parameters, node.type, node.body\n                        )\n                    );\n                    node = this.f.createPropertyAssignment(node.name, method);\n                }\n            }\n\n            if (isClassDeclaration(node)) {\n                return this.decorateClass(node);\n            } else if (isParameter(node) && node.parent && node.type) {\n                // ReceiveType\n                const typeParameters = isConstructorDeclaration(node.parent) ? node.parent.parent.typeParameters : node.parent.typeParameters;\n                if (!typeParameters) return node;\n\n                const receiveType = getReceiveTypeParameter(node.type);\n                if (receiveType && receiveType.typeArguments) {\n                    const first = receiveType.typeArguments[0];\n                    if (first && isTypeReferenceNode(first) && isIdentifier(first.typeName)) {\n                        const name = getIdentifierName(first.typeName);\n                        //find type parameter position\n                        const index = typeParameters.findIndex(v => getIdentifierName(v.name) === name);\n\n                        let container: Expression = this.f.createIdentifier('globalThis');\n                        if ((isFunctionDeclaration(node.parent) || isFunctionExpression(node.parent)) && node.parent.name) {\n                            container = node.parent.name;\n                        } else if (isMethodDeclaration(node.parent) && isIdentifier(node.parent.name)) {\n                            container = this.f.createPropertyAccessExpression(this.f.createIdentifier('this'), node.parent.name);\n                        } else if (isConstructorDeclaration(node.parent)) {\n                            container = this.f.createPropertyAccessExpression(this.f.createIdentifier('this'), 'constructor');\n                        }\n\n                        return this.f.updateParameterDeclaration(node, node.modifiers as ReadonlyArray<Modifier>, node.dotDotDotToken, node.name,\n                            node.questionToken, receiveType, this.f.createElementAccessChain(\n                                this.f.createPropertyAccessExpression(\n                                    container,\n                                    this.f.createIdentifier('Ω'),\n                                ),\n                                this.f.createToken(SyntaxKind.QuestionDotToken),\n                                this.f.createNumericLiteral(index)\n                            )\n                        );\n                    }\n                }\n            } else if (isClassExpression(node)) {\n                return this.decorateClass(node);\n            } else if (isFunctionExpression(node)) {\n                return this.decorateFunctionExpression(this.injectResetΩ(node));\n            } else if (isFunctionDeclaration(node)) {\n                return this.decorateFunctionDeclaration(this.injectResetΩ(node));\n            } else if (isMethodDeclaration(node) || isConstructorDeclaration(node)) {\n                return this.injectResetΩ(node);\n            } else if (isArrowFunction(node)) {\n                return this.decorateArrow(node);\n            } else if ((isNewExpression(node) || isCallExpression(node)) && node.typeArguments && node.typeArguments.length > 0) {\n\n                if (isCallExpression(node)) {\n                    const autoTypeFunctions = ['valuesOf', 'propertiesOf', 'typeOf'];\n                    if (isIdentifier(node.expression) && autoTypeFunctions.includes(getIdentifierName(node.expression))) {\n                        const args: Expression[] = [...node.arguments];\n\n                        if (!args.length) {\n                            args.push(this.f.createArrayLiteralExpression());\n                        }\n\n                        // const resolvedType = this.resolveType(node.typeArguments[0]);\n                        const type = this.getTypeOfType(node.typeArguments[0]);\n                        if (!type) return node;\n                        args.push(type);\n\n                        return this.f.updateCallExpression(node, node.expression, node.typeArguments, this.f.createNodeArray(args));\n                    }\n                }\n\n                //put the type argument in FN.Ω\n                const expressionToCheck = getAssignTypeExpression(node.expression) || node.expression;\n                if (isArrowFunction(expressionToCheck)) {\n                    //inline arrow functions are excluded from type passing\n                    return node;\n                }\n\n                const typeExpressions: Expression[] = [];\n                for (const a of node.typeArguments) {\n                    const type = this.getTypeOfType(a);\n                    typeExpressions.push(type || this.f.createIdentifier('undefined'));\n                }\n\n                let container: Expression = this.f.createIdentifier('globalThis');\n                if (isIdentifier(node.expression)) {\n                    container = node.expression;\n                } else if (isPropertyAccessExpression(node.expression)) {\n                    container = node.expression;\n                }\n\n                const assignQ = this.f.createBinaryExpression(\n                    this.f.createPropertyAccessExpression(container, 'Ω'),\n                    this.f.createToken(SyntaxKind.EqualsToken),\n                    this.f.createArrayLiteralExpression(typeExpressions),\n                );\n\n                const update: any = isNewExpression(node) ? this.f.updateNewExpression : this.f.updateCallExpression;\n\n                if (isPropertyAccessExpression(node.expression)) {\n                    //e.g. http.deep.response();\n                    if (isCallExpression(node.expression.expression)) {\n                        //e.g. http.deep().response();\n                        //change to (Ωr = http.deep(), Ωr.response.Ω = [], Ωr).response()\n                        const r = this.getTempResultIdentifier();\n                        const assignQ = this.f.createBinaryExpression(\n                            this.f.createPropertyAccessExpression(\n                                this.f.createPropertyAccessExpression(r, node.expression.name),\n                                'Ω'\n                            ),\n                            this.f.createToken(SyntaxKind.EqualsToken),\n                            this.f.createArrayLiteralExpression(typeExpressions),\n                        );\n\n                        return update(node,\n                            this.f.createPropertyAccessExpression(\n                                this.f.createParenthesizedExpression(this.f.createBinaryExpression(\n                                    this.f.createBinaryExpression(\n                                        this.f.createBinaryExpression(\n                                            r,\n                                            this.f.createToken(ts.SyntaxKind.EqualsToken),\n                                            node.expression.expression\n                                        ),\n                                        this.f.createToken(ts.SyntaxKind.CommaToken),\n                                        assignQ\n                                    ),\n                                    this.f.createToken(ts.SyntaxKind.CommaToken),\n                                    r\n                                )),\n                                node.expression.name\n                            ),\n                            node.typeArguments,\n                            node.arguments\n                        );\n\n                    } else if (isParenthesizedExpression(node.expression.expression)) {\n                        //e.g. (http.deep()).response();\n                        //only work necessary when `http.deep()` is using type args and was converted to:\n                        //  (Ω = [], http.deep()).response()\n\n                        //it's a call like (obj.method.Ω = ['a'], obj.method()).method()\n                        //which needs to be converted so that Ω is correctly read by the last call\n                        //(r = (obj.method.Ω = [['a']], obj.method()), obj.method.Ω = [['b']], r).method());\n\n                        const r = this.getTempResultIdentifier();\n                        const assignQ = this.f.createBinaryExpression(\n                            this.f.createPropertyAccessExpression(\n                                this.f.createPropertyAccessExpression(r, node.expression.name),\n                                'Ω'\n                            ),\n                            this.f.createToken(SyntaxKind.EqualsToken),\n                            this.f.createArrayLiteralExpression(typeExpressions),\n                        );\n\n                        const updatedNode = update(\n                            node,\n                            this.f.updatePropertyAccessExpression(\n                                node.expression,\n                                this.f.updateParenthesizedExpression(\n                                    node.expression.expression,\n                                    this.f.createBinaryExpression(\n                                        this.f.createBinaryExpression(\n                                            this.f.createBinaryExpression(\n                                                r,\n                                                this.f.createToken(SyntaxKind.EqualsToken),\n                                                node.expression.expression.expression,\n                                            ),\n                                            this.f.createToken(SyntaxKind.CommaToken),\n                                            assignQ\n                                        ),\n                                        this.f.createToken(SyntaxKind.CommaToken),\n                                        r,\n                                    )\n                                ),\n                                node.expression.name\n                            ),\n                            node.typeArguments,\n                            node.arguments\n                        );\n\n                        return this.f.createParenthesizedExpression(updatedNode);\n                    } else {\n                        //e.g. http.deep.response();\n                        //nothing to do\n                    }\n                }\n\n                //(fn.Ω = [], call())\n                return this.f.createParenthesizedExpression(this.f.createBinaryExpression(\n                    assignQ,\n                    this.f.createToken(SyntaxKind.CommaToken),\n                    node,\n                ));\n            }\n\n            return node;\n        };\n        this.sourceFile = visitNode(this.sourceFile, visitor);\n\n        while (true) {\n            let allCompiled = true;\n            for (const d of this.compileDeclarations.values()) {\n                if (d.compiled) continue;\n                allCompiled = false;\n                break;\n            }\n\n            if (this.embedDeclarations.size === 0 && allCompiled) break;\n\n            for (const [node, d] of [...this.compileDeclarations.entries()]) {\n                if (d.compiled) continue;\n                d.compiled = this.createProgramVarFromNode(node, d.name, this.sourceFile);\n            }\n\n            if (this.embedDeclarations.size) {\n                const embedded: Statement[] = [];\n                for (const node of this.embedDeclarations.keys()) {\n                    this.compiledDeclarations.add(node);\n                }\n                const entries = Array.from(this.embedDeclarations.entries());\n                this.embedDeclarations.clear();\n                for (const [node, d] of entries) {\n                    embedded.push(...this.createProgramVarFromNode(node, d.name, d.sourceFile));\n                }\n                this.sourceFile = this.f.updateSourceFile(this.sourceFile, [...embedded, ...this.sourceFile.statements]);\n            }\n        }\n\n        //externalize type aliases\n        const compileDeclarations = (node: Node): any => {\n            node = visitEachChild(node, compileDeclarations, this.context);\n\n            if ((isTypeAliasDeclaration(node) || isInterfaceDeclaration(node) || isEnumDeclaration(node))) {\n                const d = this.compileDeclarations.get(node);\n                if (!d) {\n                    return node;\n                }\n                this.compileDeclarations.delete(node);\n                this.compiledDeclarations.add(node);\n                if (d.compiled) {\n                    return [...d.compiled, node];\n                }\n            }\n\n            return node;\n        };\n        this.sourceFile = visitNode(this.sourceFile, compileDeclarations);\n\n        const embedTopExpression: Statement[] = [];\n        if (this.addImports.length) {\n            const compilerOptions = this.compilerOptions;\n            const handledIdentifier: string[] = [];\n            for (const imp of this.addImports) {\n                if (handledIdentifier.includes(getIdentifierName(imp.identifier))) continue;\n                handledIdentifier.push(getIdentifierName(imp.identifier));\n                if (compilerOptions.module === ModuleKind.CommonJS) {\n                    //var {identifier} = require('./bar')\n                    const variable = this.f.createVariableStatement(undefined, this.f.createVariableDeclarationList([this.f.createVariableDeclaration(\n                        this.f.createObjectBindingPattern([this.f.createBindingElement(undefined, undefined, imp.identifier)]),\n                        undefined, undefined,\n                        this.f.createCallExpression(this.f.createIdentifier('require'), undefined, [imp.from])\n                    )], NodeFlags.Const));\n                    const typeDeclWithComment = addSyntheticLeadingComment(\n                        variable,\n                        SyntaxKind.MultiLineCommentTrivia,\n                        '@ts-ignore',\n                        true,\n                    );\n                    embedTopExpression.push(typeDeclWithComment);\n                } else {\n                    //import {identifier} from './bar.js'\n                    // import { identifier as identifier } is used to avoid automatic elision of imports (in angular builds for example)\n                    // that's probably a bit unstable.\n                    const specifier = this.f.createImportSpecifier(false, imp.identifier, imp.identifier);\n                    const namedImports = this.f.createNamedImports([specifier]);\n                    const importStatement = this.f.createImportDeclaration(undefined,\n                        this.f.createImportClause(false, undefined, namedImports), imp.from\n                    );\n                    const typeDeclWithComment = addSyntheticLeadingComment(\n                        importStatement,\n                        SyntaxKind.MultiLineCommentTrivia,\n                        '@ts-ignore',\n                        true,\n                    );\n                    embedTopExpression.push(typeDeclWithComment);\n                }\n            }\n        }\n\n        if (this.embedAssignType) {\n            const assignType = this.f.createFunctionDeclaration(\n                undefined,\n                undefined,\n                this.f.createIdentifier('__assignType'),\n                undefined,\n                [\n                    this.f.createParameterDeclaration(\n                        undefined,\n                        undefined,\n                        this.f.createIdentifier('fn'),\n                        undefined,\n                        undefined, //this.f.createKeywordTypeNode(SyntaxKind.AnyKeyword),\n                        undefined\n                    ),\n                    this.f.createParameterDeclaration(\n                        undefined,\n                        undefined,\n                        this.f.createIdentifier('args'),\n                        undefined,\n                        undefined, //this.f.createKeywordTypeNode(SyntaxKind.AnyKeyword),\n                        undefined\n                    )\n                ],\n                undefined, //this.f.createKeywordTypeNode(SyntaxKind.AnyKeyword),\n                this.f.createBlock(\n                    [\n                        this.f.createExpressionStatement(this.f.createBinaryExpression(\n                            this.f.createPropertyAccessExpression(\n                                this.f.createIdentifier('fn'),\n                                this.f.createIdentifier('__type')\n                            ),\n                            this.f.createToken(SyntaxKind.EqualsToken),\n                            this.f.createIdentifier('args')\n                        )),\n                        this.f.createReturnStatement(this.f.createIdentifier('fn'))\n                    ],\n                    true\n                )\n            );\n            embedTopExpression.push(assignType);\n        }\n\n        if (this.tempResultIdentifier) {\n            embedTopExpression.push(\n                this.f.createVariableStatement(\n                    undefined,\n                    this.f.createVariableDeclarationList(\n                        [this.f.createVariableDeclaration(\n                            this.tempResultIdentifier,\n                            undefined,\n                            undefined,\n                            undefined\n                        )],\n                        ts.NodeFlags.None\n                    )\n                )\n            );\n        }\n\n        if (embedTopExpression.length) {\n            this.sourceFile = this.f.updateSourceFile(this.sourceFile, [...embedTopExpression, ...this.sourceFile.statements]);\n        }\n\n        // console.log('transform sourceFile', this.sourceFile.fileName);\n        // console.log(createPrinter().printNode(EmitHint.SourceFile, this.sourceFile, this.sourceFile));\n        return this.sourceFile;\n    }\n\n    protected injectResetΩ<T extends FunctionDeclaration | FunctionExpression | MethodDeclaration | ConstructorDeclaration>(node: T): T {\n        let hasReceiveType = false;\n        for (const param of node.parameters) {\n            if (param.type && getReceiveTypeParameter(param.type)) hasReceiveType = true;\n        }\n        if (!hasReceiveType) return node;\n\n        let container: Expression = this.f.createIdentifier('globalThis');\n        if ((isFunctionDeclaration(node) || isFunctionExpression(node)) && node.name) {\n            container = node.name;\n        } else if (isMethodDeclaration(node) && isIdentifier(node.name)) {\n            container = this.f.createPropertyAccessExpression(this.f.createIdentifier('this'), node.name);\n        } else if (isConstructorDeclaration(node)) {\n            container = this.f.createPropertyAccessExpression(this.f.createIdentifier('this'), 'constructor');\n        }\n\n        const reset: Statement = this.f.createExpressionStatement(this.f.createBinaryExpression(\n            this.f.createPropertyAccessExpression(\n                container,\n                this.f.createIdentifier('Ω')\n            ),\n            this.f.createToken(ts.SyntaxKind.EqualsToken),\n            this.f.createIdentifier('undefined')\n        ));\n        const body = node.body ? this.f.updateBlock(node.body, [reset, ...node.body.statements]) : undefined;\n\n        if (isFunctionDeclaration(node)) {\n            return this.f.updateFunctionDeclaration(node, node.modifiers, node.asteriskToken, node.name,\n                node.typeParameters, node.parameters, node.type, body) as T;\n        } else if (isFunctionExpression(node)) {\n            return this.f.updateFunctionExpression(node, node.modifiers, node.asteriskToken, node.name,\n                node.typeParameters, node.parameters, node.type, body || node.body) as T;\n        } else if (isMethodDeclaration(node)) {\n            return this.f.updateMethodDeclaration(node, node.modifiers as ReadonlyArray<Modifier>, node.asteriskToken, node.name,\n                node.questionToken, node.typeParameters, node.parameters, node.type, body) as T;\n        } else if (isConstructorDeclaration(node)) {\n            return this.f.updateConstructorDeclaration(node, node.modifiers, node.parameters, body) as T;\n        }\n        return node;\n    }\n\n    protected createProgramVarFromNode(node: Node, name: EntityName, sourceFile: SourceFile): Statement[] {\n        const typeProgram = new CompilerProgram(node, sourceFile);\n\n        if ((isTypeAliasDeclaration(node) || isInterfaceDeclaration(node)) && node.typeParameters) {\n            for (const param of node.typeParameters) {\n                if (param.default) {\n                    //push default on the stack\n                    this.extractPackStructOfType(param.default, typeProgram);\n                }\n                typeProgram.pushTemplateParameter(getIdentifierName(param.name), !!param.default);\n            }\n        }\n\n        if (isTypeAliasDeclaration(node)) {\n            this.extractPackStructOfType(node.type, typeProgram);\n        } else {\n            this.extractPackStructOfType(node, typeProgram);\n        }\n        const typeProgramExpression = this.packOpsAndStack(typeProgram);\n\n        const variable = this.f.createVariableStatement(\n            [],\n            this.f.createVariableDeclarationList([\n                this.f.createVariableDeclaration(\n                    this.getDeclarationVariableName(name),\n                    undefined,\n                    undefined,\n                    typeProgramExpression,\n                )\n            ], NodeFlags.Const),\n        );\n\n        //when its commonJS, the `variable` would be exported as `exports.$name = $value`, but all references point just to $name.\n        //so the idea is, that we create a normal variable and export it via `export {$name}`.\n        if (hasModifier(node, SyntaxKind.ExportKeyword)) {\n            //propertyName in ExportSpecifier is set to avoid a TS compile error:\n            // TypeError: Cannot read properties of undefined (reading 'escapedText')\n            //   at Object.idText (/Users/marc/bude/deepkit-framework/packages/benchmark/node_modules/typescript/lib/typescript.js:11875:67)\n            const exportNode = this.f.createExportDeclaration(undefined, false, this.f.createNamedExports([\n                this.f.createExportSpecifier(false, this.getDeclarationVariableName(name), this.getDeclarationVariableName(name))\n            ]));\n            return [variable, exportNode];\n        }\n\n        return [variable];\n    }\n\n    protected extractPackStructOfType(node: Node | Declaration | ClassDeclaration | ClassExpression, program: CompilerProgram): void {\n        if (isParenthesizedTypeNode(node)) return this.extractPackStructOfType(node.type, program);\n\n        switch (node.kind) {\n            case SyntaxKind.StringKeyword: {\n                program.pushOp(ReflectionOp.string);\n                break;\n            }\n            case SyntaxKind.NumberKeyword: {\n                program.pushOp(ReflectionOp.number);\n                break;\n            }\n            case SyntaxKind.BooleanKeyword: {\n                program.pushOp(ReflectionOp.boolean);\n                break;\n            }\n            case SyntaxKind.BigIntKeyword: {\n                program.pushOp(ReflectionOp.bigint);\n                break;\n            }\n            case SyntaxKind.VoidKeyword: {\n                program.pushOp(ReflectionOp.void);\n                break;\n            }\n            case SyntaxKind.UnknownKeyword: {\n                program.pushOp(ReflectionOp.unknown);\n                break;\n            }\n            case SyntaxKind.ObjectKeyword: {\n                program.pushOp(ReflectionOp.object);\n                break;\n            }\n            case SyntaxKind.SymbolKeyword: {\n                program.pushOp(ReflectionOp.symbol);\n                break;\n            }\n            case SyntaxKind.NullKeyword: {\n                program.pushOp(ReflectionOp.null);\n                break;\n            }\n            case SyntaxKind.NeverKeyword: {\n                program.pushOp(ReflectionOp.never);\n                break;\n            }\n            case SyntaxKind.AnyKeyword: {\n                program.pushOp(ReflectionOp.any);\n                break;\n            }\n            case SyntaxKind.UndefinedKeyword: {\n                program.pushOp(ReflectionOp.undefined);\n                break;\n            }\n            case SyntaxKind.TrueKeyword: {\n                program.pushOp(ReflectionOp.literal, program.pushStack(this.f.createTrue()));\n                break;\n            }\n            case SyntaxKind.FalseKeyword: {\n                program.pushOp(ReflectionOp.literal, program.pushStack(this.f.createFalse()));\n                break;\n            }\n            case SyntaxKind.ClassDeclaration:\n            case SyntaxKind.ClassExpression: {\n                //TypeScript does not narrow types down\n                const narrowed = node as ClassDeclaration | ClassExpression;\n                //class nodes have always their own program, so the start is always fresh, means we don't need a frame\n\n                if (node) {\n                    const members: ClassElement[] = [];\n\n                    if (narrowed.typeParameters) {\n                        for (const typeParameter of narrowed.typeParameters) {\n                            const name = getNameAsString(typeParameter.name);\n                            if (typeParameter.default) {\n                                //push default on the stack\n                                this.extractPackStructOfType(typeParameter.default, program);\n                            }\n                            program.pushTemplateParameter(name, !!typeParameter.default);\n                        }\n                    }\n\n                    if (narrowed.heritageClauses) {\n                        for (const heritage of narrowed.heritageClauses) {\n                            if (heritage.token === SyntaxKind.ExtendsKeyword) {\n                                for (const extendType of heritage.types) {\n                                    program.pushFrame();\n                                    if (extendType.typeArguments) {\n                                        for (const typeArgument of extendType.typeArguments) {\n                                            this.extractPackStructOfType(typeArgument, program);\n                                        }\n                                    }\n                                    const index = program.pushStack(this.f.createArrowFunction(undefined, undefined, [], undefined, undefined, this.nodeConverter.toExpression(extendType.expression)));\n                                    program.pushOp(ReflectionOp.classReference, index);\n                                    program.popFrameImplicit();\n                                }\n                            }\n                        }\n                    }\n\n                    for (const member of narrowed.members) {\n                        const name = getNameAsString(member.name);\n                        if (name) {\n                            const has = members.some(v => getNameAsString(v.name) === name);\n                            if (has) continue;\n                        }\n                        members.push(member);\n\n                        this.extractPackStructOfType(member, program);\n                    }\n\n                    program.pushOp(ReflectionOp.class);\n\n                    if (narrowed.heritageClauses && narrowed.heritageClauses[0] && narrowed.heritageClauses[0].types[0]) {\n                        const first = narrowed.heritageClauses[0].types[0];\n                        if (isExpressionWithTypeArguments(first) && first.typeArguments) {\n                            for (const typeArgument of first.typeArguments) {\n                                this.extractPackStructOfType(typeArgument, program);\n                            }\n\n                            program.pushOp(ReflectionOp.classExtends, first.typeArguments.length);\n                        }\n                    }\n\n                }\n                break;\n            }\n            case SyntaxKind.IntersectionType: {\n                //TypeScript does not narrow types down\n                const narrowed = node as IntersectionTypeNode;\n                program.pushFrame();\n\n                for (const type of narrowed.types) {\n                    this.extractPackStructOfType(type, program);\n                }\n\n                program.pushOp(ReflectionOp.intersection);\n                program.popFrameImplicit();\n                break;\n            }\n            case SyntaxKind.MappedType: {\n                //TypeScript does not narrow types down\n                const narrowed = node as MappedTypeNode;\n\n                //<Type>{[Property in keyof Type]: boolean;};\n                program.pushFrame();\n                program.pushVariable(getIdentifierName(narrowed.typeParameter.name));\n\n                const constraint = getEffectiveConstraintOfTypeParameter(narrowed.typeParameter);\n                if (constraint) {\n                    this.extractPackStructOfType(constraint, program);\n                } else {\n                    program.pushOp(ReflectionOp.never);\n                }\n\n                let modifier = 0;\n                if (narrowed.questionToken) {\n                    if (narrowed.questionToken.kind === SyntaxKind.QuestionToken) {\n                        modifier |= MappedModifier.optional;\n                    }\n                    if (narrowed.questionToken.kind === SyntaxKind.MinusToken) {\n                        modifier |= MappedModifier.removeOptional;\n                    }\n                }\n                if (narrowed.readonlyToken) {\n                    if (narrowed.readonlyToken.kind === SyntaxKind.ReadonlyKeyword) {\n                        modifier |= MappedModifier.readonly;\n                    }\n                    if (narrowed.readonlyToken.kind === SyntaxKind.MinusToken) {\n                        modifier |= MappedModifier.removeReadonly;\n                    }\n                }\n                program.pushCoRoutine();\n                if (narrowed.nameType) program.pushFrame();\n                if (narrowed.type) {\n                    this.extractPackStructOfType(narrowed.type, program);\n                } else {\n                    program.pushOp(ReflectionOp.never);\n                }\n                if (narrowed.nameType) {\n                    this.extractPackStructOfType(narrowed.nameType, program);\n                    program.pushOp(ReflectionOp.tuple);\n                    program.popFrameImplicit();\n                }\n                const coRoutineIndex = program.popCoRoutine();\n\n                if (narrowed.nameType) {\n                    program.pushOp(ReflectionOp.mappedType2, coRoutineIndex, modifier);\n                } else {\n                    program.pushOp(ReflectionOp.mappedType, coRoutineIndex, modifier);\n                }\n\n                program.popFrameImplicit();\n                break;\n            }\n            case SyntaxKind.TypeLiteral:\n            case SyntaxKind.InterfaceDeclaration: {\n                //TypeScript does not narrow types down\n                const narrowed = node as TypeLiteralNode | InterfaceDeclaration;\n                program.pushFrame();\n\n                //first all extend expressions\n                if (isInterfaceDeclaration(narrowed) && narrowed.heritageClauses) {\n                    for (const heritage of narrowed.heritageClauses) {\n                        if (heritage.token === SyntaxKind.ExtendsKeyword) {\n                            for (const extendType of heritage.types) {\n                                this.extractPackStructOfTypeReference(extendType, program);\n                            }\n                        }\n                    }\n                }\n\n                for (const member of narrowed.members) {\n                    this.extractPackStructOfType(member, program);\n                }\n                program.pushOp(ReflectionOp.objectLiteral);\n                program.popFrameImplicit();\n                break;\n            }\n            case SyntaxKind.TypeReference: {\n                this.extractPackStructOfTypeReference(node as TypeReferenceNode, program);\n                break;\n            }\n            case SyntaxKind.ArrayType: {\n                this.extractPackStructOfType((node as ArrayTypeNode).elementType, program);\n                program.pushOp(ReflectionOp.array);\n                break;\n            }\n            case SyntaxKind.RestType: {\n                let type = (node as RestTypeNode).type;\n                if (isArrayTypeNode(type)) {\n                    type = type.elementType;\n                }\n                this.extractPackStructOfType(type, program);\n                program.pushOp(ReflectionOp.rest);\n                break;\n            }\n            case SyntaxKind.TupleType: {\n                program.pushFrame();\n                for (const element of (node as TupleTypeNode).elements) {\n                    if (isOptionalTypeNode(element)) {\n                        this.extractPackStructOfType(element.type, program);\n                        program.pushOp(ReflectionOp.tupleMember);\n                        program.pushOp(ReflectionOp.optional);\n                    } else if (isNamedTupleMember(element)) {\n                        if (element.dotDotDotToken) {\n                            let type = element.type;\n                            if (isArrayTypeNode(type)) {\n                                type = type.elementType;\n                            }\n                            this.extractPackStructOfType(type, program);\n                            program.pushOp(ReflectionOp.rest);\n                        } else {\n                            this.extractPackStructOfType(element.type, program);\n                        }\n                        const index = program.findOrAddStackEntry(getIdentifierName(element.name));\n                        program.pushOp(ReflectionOp.namedTupleMember, index);\n                        if (element.questionToken) {\n                            program.pushOp(ReflectionOp.optional);\n                        }\n                    } else {\n                        this.extractPackStructOfType(element, program);\n                    }\n                }\n                program.pushOp(ReflectionOp.tuple);\n                program.popFrameImplicit();\n                break;\n            }\n            case SyntaxKind.PropertySignature: {\n                //TypeScript does not narrow types down\n                const narrowed = node as PropertySignature;\n                if (narrowed.type) {\n                    this.extractPackStructOfType(narrowed.type, program);\n                    const name = getPropertyName(this.f, narrowed.name);\n                    program.pushOp(ReflectionOp.propertySignature, program.findOrAddStackEntry(name));\n                    if (narrowed.questionToken) program.pushOp(ReflectionOp.optional);\n                    if (hasModifier(narrowed, SyntaxKind.ReadonlyKeyword)) program.pushOp(ReflectionOp.readonly);\n\n                    const description = extractJSDocAttribute(narrowed, 'description');\n                    if (description) program.pushOp(ReflectionOp.description, program.findOrAddStackEntry(description));\n                }\n                break;\n            }\n            case SyntaxKind.PropertyDeclaration: {\n                //TypeScript does not narrow types down\n                const narrowed = node as PropertyDeclaration;\n\n                if (narrowed.type) {\n                    const config = this.findReflectionConfig(narrowed, program);\n                    if (config.mode === 'never') return;\n\n                    this.extractPackStructOfType(narrowed.type, program);\n                    const name = getPropertyName(this.f, narrowed.name);\n                    program.pushOp(ReflectionOp.property, program.findOrAddStackEntry(name));\n\n                    if (narrowed.questionToken) program.pushOp(ReflectionOp.optional);\n                    if (hasModifier(narrowed, SyntaxKind.ReadonlyKeyword)) program.pushOp(ReflectionOp.readonly);\n                    if (hasModifier(narrowed, SyntaxKind.PrivateKeyword)) program.pushOp(ReflectionOp.private);\n                    if (hasModifier(narrowed, SyntaxKind.ProtectedKeyword)) program.pushOp(ReflectionOp.protected);\n                    if (hasModifier(narrowed, SyntaxKind.AbstractKeyword)) program.pushOp(ReflectionOp.abstract);\n                    if (hasModifier(narrowed, SyntaxKind.StaticKeyword)) program.pushOp(ReflectionOp.static);\n\n                    if (narrowed.initializer) {\n                        //important to use Function, since it will be called using a different `this`\n                        program.pushOp(ReflectionOp.defaultValue, program.findOrAddStackEntry(this.f.createFunctionExpression(undefined, undefined, undefined, undefined, undefined, undefined,\n                            this.f.createBlock([this.f.createReturnStatement(narrowed.initializer)]))\n                        ));\n                    }\n\n                    const description = extractJSDocAttribute(narrowed, 'description');\n                    if (description) program.pushOp(ReflectionOp.description, program.findOrAddStackEntry(description));\n                }\n                break;\n            }\n            case SyntaxKind.ConditionalType: {\n                //TypeScript does not narrow types down\n                const narrowed = node as ConditionalTypeNode;\n\n\n                // Depending on whether this a distributive conditional type or not, it has to be moved to its own function\n                // my understanding of when a distributive conditional type is used is:\n                // 1. the `checkType` is a simple identifier (just `T`, no `[T]`, no `T | x`, no `{a: T}`, etc)\n                let distributiveOverIdentifier: Identifier | undefined = isTypeReferenceNode(narrowed.checkType) && isIdentifier(narrowed.checkType.typeName) ? narrowed.checkType.typeName : undefined;\n\n                if (distributiveOverIdentifier) {\n                    program.pushFrame();\n                    //first we add to the stack the origin type we distribute over.\n                    this.extractPackStructOfType(narrowed.checkType, program);\n\n                    //since the distributive conditional type is a loop that changes only the found `T`, it is necessary to add that as variable,\n                    //so call convention can take over.\n                    program.pushVariable(getIdentifierName(distributiveOverIdentifier));\n                    program.pushCoRoutine();\n                }\n\n                program.pushConditionalFrame(); //gets its own frame for `infer T` ops. all infer variables will be registered in this frame\n                this.extractPackStructOfType(narrowed.checkType, program);\n                this.extractPackStructOfType(narrowed.extendsType, program);\n\n                program.pushOp(ReflectionOp.extends);\n\n                program.pushCoRoutine();\n                this.extractPackStructOfType(narrowed.trueType, program);\n                const trueProgram = program.popCoRoutine();\n\n                program.pushCoRoutine();\n                this.extractPackStructOfType(narrowed.falseType, program);\n                const falseProgram = program.popCoRoutine();\n\n                program.pushOp(ReflectionOp.jumpCondition, trueProgram, falseProgram);\n                program.moveFrame(); //pops frame\n\n                if (distributiveOverIdentifier) {\n                    const coRoutineIndex = program.popCoRoutine();\n                    program.pushOp(ReflectionOp.distribute, coRoutineIndex);\n                    program.popFrameImplicit();\n                }\n                break;\n            }\n            case SyntaxKind.InferType: {\n                //TypeScript does not narrow types down\n                const narrowed = node as InferTypeNode;\n\n                const frame = program.findConditionalFrame();\n                if (frame) {\n                    const typeParameterName = getIdentifierName(narrowed.typeParameter.name);\n                    let variable = program.findVariable(typeParameterName);\n                    if (!variable) {\n                        program.pushVariable(typeParameterName, frame);\n                        variable = program.findVariable(typeParameterName);\n                        if (!variable) throw new Error('Could not find inserted infer variable');\n                    }\n                    program.pushOp(ReflectionOp.infer, variable.frameOffset, variable.stackIndex);\n                } else {\n                    program.pushOp(ReflectionOp.never);\n                }\n                break;\n            }\n            case SyntaxKind.MethodSignature:\n            case SyntaxKind.MethodDeclaration:\n            case SyntaxKind.Constructor:\n            case SyntaxKind.ArrowFunction:\n            case SyntaxKind.FunctionExpression:\n            case SyntaxKind.ConstructSignature:\n            case SyntaxKind.ConstructorType:\n            case SyntaxKind.FunctionType:\n            case SyntaxKind.CallSignature:\n            case SyntaxKind.FunctionDeclaration: {\n                //TypeScript does not narrow types down\n                const narrowed = node as MethodSignature | MethodDeclaration | CallSignatureDeclaration | ConstructorTypeNode | ConstructSignatureDeclaration | ConstructorDeclaration | ArrowFunction | FunctionExpression | FunctionTypeNode | FunctionDeclaration;\n\n                const config = this.findReflectionConfig(narrowed, program);\n                if (config.mode === 'never') return;\n\n                const name = isCallSignatureDeclaration(node) ? '' : isConstructorTypeNode(narrowed) || isConstructSignatureDeclaration(node) ? 'new' : isConstructorDeclaration(narrowed) ? 'constructor' : getPropertyName(this.f, narrowed.name);\n                if (!narrowed.type && narrowed.parameters.length === 0 && !name) return;\n\n                program.pushFrame();\n                for (let i = 0; i < narrowed.parameters.length; i++) {\n                    const parameter = narrowed.parameters[i];\n                    const parameterName = isIdentifier(parameter.name) ? getNameAsString(parameter.name) : 'param' + i;\n\n                    const type = parameter.type ? (parameter.dotDotDotToken && isArrayTypeNode(parameter.type) ? parameter.type.elementType : parameter.type) : undefined;\n\n                    if (type) {\n                        this.extractPackStructOfType(type, program);\n                    } else {\n                        program.pushOp(ReflectionOp.any);\n                    }\n\n                    if (parameter.dotDotDotToken) {\n                        program.pushOp(ReflectionOp.rest);\n                    }\n\n                    program.pushOp(ReflectionOp.parameter, program.findOrAddStackEntry(parameterName));\n\n                    if (parameter.questionToken) program.pushOp(ReflectionOp.optional);\n                    if (hasModifier(parameter, SyntaxKind.PublicKeyword)) program.pushOp(ReflectionOp.public);\n                    if (hasModifier(parameter, SyntaxKind.PrivateKeyword)) program.pushOp(ReflectionOp.private);\n                    if (hasModifier(parameter, SyntaxKind.ProtectedKeyword)) program.pushOp(ReflectionOp.protected);\n                    if (hasModifier(parameter, SyntaxKind.ReadonlyKeyword)) program.pushOp(ReflectionOp.readonly);\n                    if (parameter.initializer && parameter.type && !getReceiveTypeParameter(parameter.type)) {\n                        program.pushOp(ReflectionOp.defaultValue, program.findOrAddStackEntry(this.f.createArrowFunction(undefined, undefined, [], undefined, undefined, parameter.initializer)));\n                    }\n                }\n\n                if (narrowed.type) {\n                    this.extractPackStructOfType(narrowed.type, program);\n                } else {\n                    program.pushOp(ReflectionOp.any);\n                }\n\n                program.pushOp(\n                    isCallSignatureDeclaration(node) ? ReflectionOp.callSignature :\n                        isMethodSignature(narrowed) || isConstructSignatureDeclaration(narrowed)\n                            ? ReflectionOp.methodSignature\n                            : isMethodDeclaration(narrowed) || isConstructorDeclaration(narrowed)\n                                ? ReflectionOp.method : ReflectionOp.function, program.findOrAddStackEntry(name)\n                );\n\n                if (isMethodDeclaration(narrowed)) {\n                    if (hasModifier(narrowed, SyntaxKind.PrivateKeyword)) program.pushOp(ReflectionOp.private);\n                    if (hasModifier(narrowed, SyntaxKind.ProtectedKeyword)) program.pushOp(ReflectionOp.protected);\n                    if (hasModifier(narrowed, SyntaxKind.AbstractKeyword)) program.pushOp(ReflectionOp.abstract);\n                    if (hasModifier(narrowed, SyntaxKind.StaticKeyword)) program.pushOp(ReflectionOp.static);\n                }\n                program.popFrameImplicit();\n                break;\n            }\n            case SyntaxKind.LiteralType: {\n                //TypeScript does not narrow types down\n                const narrowed = node as LiteralTypeNode;\n\n                if (narrowed.literal.kind === SyntaxKind.NullKeyword) {\n                    program.pushOp(ReflectionOp.null);\n                } else {\n                    program.pushOp(ReflectionOp.literal, program.findOrAddStackEntry(narrowed.literal));\n                }\n                break;\n            }\n            case SyntaxKind.TemplateLiteralType: {\n                //TypeScript does not narrow types down\n                const narrowed = node as TemplateLiteralTypeNode;\n\n                program.pushFrame();\n                if (narrowed.head.rawText) {\n                    program.pushOp(ReflectionOp.literal, program.findOrAddStackEntry(narrowed.head.rawText));\n                }\n\n                for (const span of narrowed.templateSpans) {\n                    this.extractPackStructOfType(span.type, program);\n                    if (span.literal.rawText) {\n                        program.pushOp(ReflectionOp.literal, program.findOrAddStackEntry(span.literal.rawText));\n                    }\n                }\n\n                program.pushOp(ReflectionOp.templateLiteral);\n                program.popFrameImplicit();\n\n                break;\n            }\n            case SyntaxKind.UnionType: {\n                //TypeScript does not narrow types down\n                const narrowed = node as UnionTypeNode;\n\n                if (narrowed.types.length === 0) {\n                    //nothing to emit\n                } else if (narrowed.types.length === 1) {\n                    //only emit the type\n                    this.extractPackStructOfType(narrowed.types[0], program);\n                } else {\n                    program.pushFrame();\n\n                    for (const subType of narrowed.types) {\n                        this.extractPackStructOfType(subType, program);\n                    }\n\n                    program.pushOp(ReflectionOp.union);\n                    program.popFrameImplicit();\n                }\n                break;\n            }\n            case SyntaxKind.EnumDeclaration: {\n                //TypeScript does not narrow types down\n                const narrowed = node as EnumDeclaration;\n                program.pushFrame();\n\n                for (const type of narrowed.members) {\n                    const name = getPropertyName(this.f, type.name);\n                    program.pushOp(ReflectionOp.enumMember, program.findOrAddStackEntry(name));\n                    if (type.initializer) {\n                        program.pushOp(ReflectionOp.defaultValue, program.findOrAddStackEntry(this.f.createArrowFunction(undefined, undefined, [], undefined, undefined, type.initializer)));\n                    }\n                }\n                program.pushOp(ReflectionOp.enum);\n                program.popFrameImplicit();\n                break;\n            }\n            case SyntaxKind.IndexSignature: {\n                //TypeScript does not narrow types down\n                const narrowed = node as IndexSignatureDeclaration;\n\n                //node.parameters = first item is {[name: string]: number} => 'name: string'\n                if (narrowed.parameters.length && narrowed.parameters[0].type) {\n                    this.extractPackStructOfType(narrowed.parameters[0].type, program);\n                } else {\n                    program.pushOp(ReflectionOp.any);\n                }\n\n                //node.type = first item is {[name: string]: number} => 'number'\n                this.extractPackStructOfType(narrowed.type, program);\n                program.pushOp(ReflectionOp.indexSignature);\n                break;\n            }\n            case SyntaxKind.TypeQuery: {\n                //TypeScript does not narrow types down\n                const narrowed = node as TypeQueryNode;\n\n                // if (program.importSpecifier) {\n                //     //if this is set, the current program is embedded into another file. All locally used symbols like a variable in `typeof` need to be imported\n                //     //in the other file as well.\n                //     if (isIdentifier(narrowed.exprName)) {\n                //         const originImportStatement = program.importSpecifier.parent.parent.parent;\n                //         this.addImports.push({ identifier: narrowed.exprName, from: originImportStatement.moduleSpecifier });\n                //     }\n                // }\n                if (isIdentifier(narrowed.exprName)) {\n                    const resolved = this.resolveDeclaration(narrowed.exprName);\n                    if (resolved && findSourceFile(resolved.declaration) !== this.sourceFile && resolved.importDeclaration) {\n                        ensureImportIsEmitted(resolved.importDeclaration, narrowed.exprName);\n                    }\n                }\n\n                const expression = serializeEntityNameAsExpression(this.f, narrowed.exprName);\n                program.pushOp(ReflectionOp.typeof, program.pushStack(this.f.createArrowFunction(undefined, undefined, [], undefined, undefined, expression)));\n                break;\n            }\n            case SyntaxKind.TypeOperator: {\n                //TypeScript does not narrow types down\n                const narrowed = node as TypeOperatorNode;\n\n                if (narrowed.type.kind === SyntaxKind.ThisType) {\n                    //for the moment we treat `keyof this` as any, since `this` is not implemented at all.\n                    //this makes it possible that the code above works at least.\n                    program.pushOp(ReflectionOp.any);\n                    break;\n                }\n\n                switch (narrowed.operator) {\n                    case SyntaxKind.KeyOfKeyword: {\n                        this.extractPackStructOfType(narrowed.type, program);\n                        program.pushOp(ReflectionOp.keyof);\n                        break;\n                    }\n                    case SyntaxKind.ReadonlyKeyword: {\n                        this.extractPackStructOfType(narrowed.type, program);\n                        program.pushOp(ReflectionOp.readonly);\n                        break;\n                    }\n                    default: {\n                        program.pushOp(ReflectionOp.never);\n                    }\n                }\n                break;\n            }\n            case SyntaxKind.IndexedAccessType: {\n                //TypeScript does not narrow types down\n                const narrowed = node as IndexedAccessTypeNode;\n\n                this.extractPackStructOfType(narrowed.objectType, program);\n                this.extractPackStructOfType(narrowed.indexType, program);\n                program.pushOp(ReflectionOp.indexAccess);\n                break;\n            }\n            case SyntaxKind.Identifier: {\n                //TypeScript does not narrow types down\n                const narrowed = node as Identifier;\n\n                //check if it references a variable\n                const variable = program.findVariable(getIdentifierName(narrowed));\n                if (variable) {\n                    program.pushOp(ReflectionOp.loads, variable.frameOffset, variable.stackIndex);\n                }\n                break;\n            }\n            default: {\n                program.pushOp(ReflectionOp.never);\n            }\n        }\n    }\n\n    protected knownClasses: { [name: string]: ReflectionOp } = {\n        'Int8Array': ReflectionOp.int8Array,\n        'Uint8Array': ReflectionOp.uint8Array,\n        'Uint8ClampedArray': ReflectionOp.uint8ClampedArray,\n        'Int16Array': ReflectionOp.int16Array,\n        'Uint16Array': ReflectionOp.uint16Array,\n        'Int32Array': ReflectionOp.int32Array,\n        'Uint32Array': ReflectionOp.uint32Array,\n        'Float32Array': ReflectionOp.float32Array,\n        'Float64Array': ReflectionOp.float64Array,\n        'ArrayBuffer': ReflectionOp.arrayBuffer,\n        'BigInt64Array': ReflectionOp.bigInt64Array,\n        'Date': ReflectionOp.date,\n        'RegExp': ReflectionOp.regexp,\n        'String': ReflectionOp.string,\n        'Number': ReflectionOp.number,\n        'BigInt': ReflectionOp.bigint,\n        'Boolean': ReflectionOp.boolean,\n    };\n\n    protected globalSourceFiles?: SourceFile[];\n\n    protected getGlobalLibs(): SourceFile[] {\n        if (this.globalSourceFiles) return this.globalSourceFiles;\n\n        this.globalSourceFiles = [];\n\n        //todo also read compiler options \"types\" + typeRoot\n\n        //currently knownLibFilesForCompilerOptions from @typescript/vfs doesn't return correct lib files for ES2022,\n        //so we switch here to es2021 if bigger than es2021.\n        const options: ts.CompilerOptions = { ...this.compilerOptions };\n        if (options.target && (options.target > ScriptTarget.ES2021 && options.target < ScriptTarget.ESNext)) {\n            options.target = ScriptTarget.ES2021;\n        }\n        //@ts-ignore\n        const libs = knownLibFilesForCompilerOptions(options, ts);\n\n        for (const lib of libs) {\n            const sourceFile = this.resolver.resolveSourceFile(this.sourceFile.fileName, 'typescript/lib/' + lib.replace('.d.ts', ''));\n            if (!sourceFile) continue;\n            this.globalSourceFiles.push(sourceFile);\n        }\n        return this.globalSourceFiles;\n    }\n\n    /**\n     * This is a custom resolver based on populated `locals` from the binder. It uses a custom resolution algorithm since\n     * we have no access to the binder/TypeChecker directly and instantiating a TypeChecker per file/transformer is incredible slow.\n     */\n    protected resolveDeclaration(typeName: EntityName): { declaration: Node, importDeclaration?: ImportDeclaration, typeOnly?: boolean } | void {\n        let current: Node = typeName.parent;\n        if (typeName.kind === SyntaxKind.QualifiedName) return; //namespace access not supported yet, e.g. type a = Namespace.X;\n\n        let declaration: Node | undefined = undefined;\n\n        while (current) {\n            if (isNodeWithLocals(current) && current.locals) {\n                const found = current.locals.get(typeName.escapedText);\n                if (found && found.declarations && found.declarations[0]) {\n                    declaration = found.declarations[0];\n                    break;\n                }\n            }\n\n            if (current.kind === SyntaxKind.SourceFile) break;\n            current = current.parent;\n        }\n\n        if (!declaration) {\n            // look in globals, read through all files, see checker.ts initializeTypeChecker\n            for (const file of this.getGlobalLibs()) {\n                const globals = getGlobalsOfSourceFile(file);\n                if (!globals) continue;\n                const symbol = globals.get(typeName.escapedText);\n                if (symbol && symbol.declarations && symbol.declarations[0]) {\n                    declaration = symbol.declarations[0];\n                    // console.log('found global', typeName.escapedText, 'in', file.fileName);\n                    break;\n                }\n            }\n        }\n\n        let importDeclaration: ImportDeclaration | undefined = undefined;\n        let typeOnly = false;\n\n        if (declaration && isImportSpecifier(declaration)) {\n            if (declaration.isTypeOnly) typeOnly = true;\n            importDeclaration = declaration.parent.parent.parent;\n        } else if (declaration && isImportDeclaration(declaration)) {\n            // declaration = this.resolveImportSpecifier(typeName.escapedText, declaration);\n            importDeclaration = declaration;\n        } else if (declaration && isImportClause(declaration)) {\n            importDeclaration = declaration.parent;\n        }\n\n        if (importDeclaration) {\n            if (importDeclaration.importClause && importDeclaration.importClause.isTypeOnly) typeOnly = true;\n            declaration = this.resolveImportSpecifier(typeName.escapedText, importDeclaration, this.sourceFile);\n        }\n\n        if (declaration && declaration.kind === SyntaxKind.TypeParameter && declaration.parent.kind === SyntaxKind.TypeAliasDeclaration) {\n            //for alias like `type MyAlias<T> = T`, `T` is returned from `typeChecker.getDeclaredTypeOfSymbol(symbol)`.\n            declaration = declaration.parent as TypeAliasDeclaration;\n        }\n\n        if (!declaration) return;\n\n        return { declaration, importDeclaration, typeOnly };\n    }\n\n    // protected resolveType(node: TypeNode): Declaration | Node {\n    //     // if (isTypeReferenceNode(node)) {\n    //     //     const resolved = this.resolveDeclaration(node.typeName);\n    //     //     if (resolved) return resolved.declaration;\n    //     //     // } else if (isIndexedAccessTypeNode(node)) {\n    //     //     //     const resolved = this.resolveDeclaration(node);\n    //     //     //     if (resolved) return resolved.declaration;\n    //     // }\n    //\n    //     const typeChecker = this.getTypeCheckerForSource();\n    //     const type = typeChecker.getTypeFromTypeNode(node);\n    //     if (type.symbol) {\n    //         const declaration: Declaration | undefined = type.symbol && type.symbol.declarations ? type.symbol.declarations[0] : undefined;\n    //         if (declaration) return declaration;\n    //     } else {\n    //         return tsTypeToNode(this.f, type);\n    //     }\n    //     return node;\n    // }\n\n    protected getDeclarationVariableName(typeName: EntityName): Identifier {\n        if (isIdentifier(typeName)) {\n            return this.f.createIdentifier('__Ω' + getIdentifierName(typeName));\n        }\n\n        function joinQualifiedName(name: EntityName): string {\n            if (isIdentifier(name)) return getIdentifierName(name);\n            return joinQualifiedName(name.left) + '_' + getIdentifierName(name.right);\n        }\n\n        return this.f.createIdentifier('__Ω' + joinQualifiedName(typeName));\n    }\n\n    protected isExcluded(filePath: string): boolean {\n        if (!this.currentReflectionConfig.options.exclude) return false;\n\n        return contains(filePath, this.currentReflectionConfig.options.exclude, {\n            basename: true,\n            cwd: this.currentReflectionConfig.baseDir\n        });\n    }\n\n    protected extractPackStructOfTypeReference(type: TypeReferenceNode | ExpressionWithTypeArguments, program: CompilerProgram): void {\n        const typeName: EntityName | undefined = isTypeReferenceNode(type) ? type.typeName : (isIdentifier(type.expression) ? type.expression : undefined);\n        if (!typeName) {\n            program.pushOp(ReflectionOp.any);\n            return;\n        }\n\n        if (isIdentifier(typeName) && getIdentifierName(typeName) === 'InlineRuntimeType' && type.typeArguments && type.typeArguments[0] && isTypeQueryNode(type.typeArguments[0])) {\n            const expression = serializeEntityNameAsExpression(this.f, type.typeArguments[0].exprName);\n            program.pushOp(ReflectionOp.arg, program.pushStack(expression));\n            return;\n        }\n\n        if (isIdentifier(typeName) && getIdentifierName(typeName) !== 'constructor' && this.knownClasses[getIdentifierName(typeName)]) {\n            const name = getIdentifierName(typeName);\n            const op = this.knownClasses[name];\n            program.pushOp(op);\n        } else if (isIdentifier(typeName) && getIdentifierName(typeName) === 'Promise') {\n            //promise has always one sub type\n            if (type.typeArguments && type.typeArguments[0]) {\n                this.extractPackStructOfType(type.typeArguments[0], program);\n            } else {\n                program.pushOp(ReflectionOp.any);\n            }\n            program.pushOp(ReflectionOp.promise);\n        } else if (isIdentifier(typeName) && getIdentifierName(typeName) === 'integer') {\n            program.pushOp(ReflectionOp.numberBrand, TypeNumberBrand.integer as number);\n        } else if (isIdentifier(typeName) && getIdentifierName(typeName) !== 'constructor' && TypeNumberBrand[getIdentifierName(typeName) as any] !== undefined) {\n            program.pushOp(ReflectionOp.numberBrand, TypeNumberBrand[getIdentifierName(typeName) as any] as any);\n        } else {\n            //check if it references a variable\n            if (isIdentifier(typeName)) {\n                const variable = program.findVariable(getIdentifierName(typeName));\n                if (variable) {\n                    program.pushOp(ReflectionOp.loads, variable.frameOffset, variable.stackIndex);\n                    return;\n                }\n            } else if (isInferTypeNode(typeName)) {\n                this.extractPackStructOfType(typeName, program);\n                return;\n            }\n\n            const resolved = this.resolveDeclaration(typeName);\n            if (!resolved) {\n                //maybe reference to enum\n                if (isQualifiedName(typeName)) {\n                    if (isIdentifier(typeName.left)) {\n                        const resolved = this.resolveDeclaration(typeName.left);\n                        if (resolved && isEnumDeclaration(resolved.declaration)) {\n                            let lastExpression: Expression | undefined;\n                            let indexValue: number = 0;\n                            for (const member of resolved.declaration.members) {\n                                if (getNameAsString(member.name) === getNameAsString(typeName.right)) {\n                                    if (member.initializer) {\n                                        program.pushOp(ReflectionOp.arg, program.pushStack(this.nodeConverter.toExpression(member.initializer)));\n                                    } else if (lastExpression) {\n                                        const exp = this.nodeConverter.toExpression(lastExpression);\n                                        program.pushOp(ReflectionOp.arg, program.pushStack(\n                                            this.f.createBinaryExpression(exp, SyntaxKind.PlusToken, this.nodeConverter.toExpression(indexValue))\n                                        ));\n                                    } else {\n                                        program.pushOp(ReflectionOp.arg, program.pushStack(this.nodeConverter.toExpression(indexValue)));\n                                    }\n                                    return;\n                                } else {\n                                    indexValue++;\n                                    if (member.initializer) {\n                                        lastExpression = member.initializer;\n                                        //restart index\n                                        indexValue = 0;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                //non-existing references are ignored.\n                program.pushOp(ReflectionOp.never);\n                return;\n            }\n\n            let declaration: Node = resolved.declaration;\n            if (isVariableDeclaration(declaration)) {\n                if (declaration.type) {\n                    declaration = declaration.type;\n                } else if (declaration.initializer) {\n                    declaration = declaration.initializer;\n                }\n            }\n\n            if (isModuleDeclaration(declaration) && resolved.importDeclaration) {\n                if (isIdentifier(typeName)) ensureImportIsEmitted(resolved.importDeclaration, typeName);\n\n                //we can not infer from module declaration, so do `typeof T` in runtime\n                program.pushOp(ReflectionOp.typeof, program.pushStack(this.f.createArrowFunction(undefined, undefined, [], undefined, undefined, serializeEntityNameAsExpression(this.f, typeName))));\n            } else if (isTypeAliasDeclaration(declaration) || isInterfaceDeclaration(declaration) || isEnumDeclaration(declaration)) {\n                //Set/Map are interface declarations\n                const name = getNameAsString(typeName);\n                if (name === 'Array') {\n                    if (type.typeArguments && type.typeArguments[0]) {\n                        this.extractPackStructOfType(type.typeArguments[0], program);\n                    } else {\n                        program.pushOp(ReflectionOp.any);\n                    }\n\n                    program.pushOp(ReflectionOp.array);\n                    return;\n                } else if (name === 'Function') {\n                    program.pushOp(ReflectionOp.frame);\n                    program.pushOp(ReflectionOp.any);\n                    program.pushOp(ReflectionOp.function, program.pushStack(''));\n                    return;\n                } else if (name === 'Set') {\n                    if (type.typeArguments && type.typeArguments[0]) {\n                        this.extractPackStructOfType(type.typeArguments[0], program);\n                    } else {\n                        program.pushOp(ReflectionOp.any);\n                    }\n                    program.pushOp(ReflectionOp.set);\n                    return;\n                } else if (name === 'Map') {\n                    if (type.typeArguments && type.typeArguments[0]) {\n                        this.extractPackStructOfType(type.typeArguments[0], program);\n                    } else {\n                        program.pushOp(ReflectionOp.any);\n                    }\n                    if (type.typeArguments && type.typeArguments[1]) {\n                        this.extractPackStructOfType(type.typeArguments[1], program);\n                    } else {\n                        program.pushOp(ReflectionOp.any);\n                    }\n                    program.pushOp(ReflectionOp.map);\n                    return;\n                }\n\n                //to break recursion, we track which declaration has already been compiled\n                if (!this.compiledDeclarations.has(declaration) && !this.compileDeclarations.has(declaration)) {\n                    const declarationSourceFile = findSourceFile(declaration) || this.sourceFile;\n                    const isGlobal = resolved.importDeclaration === undefined && declarationSourceFile.fileName !== this.sourceFile.fileName;\n                    const isFromImport = resolved.importDeclaration !== undefined;\n\n                    if (this.isExcluded(declarationSourceFile.fileName)) {\n                        program.pushOp(ReflectionOp.any);\n                        return;\n                    }\n\n                    if (isGlobal) {\n                        //we don't embed non-global imported declarations anymore, only globals\n                        this.embedDeclarations.set(declaration, {\n                            name: typeName,\n                            sourceFile: declarationSourceFile\n                        });\n                    } else if (isFromImport) {\n                        if (resolved.importDeclaration) {\n                            //if explicit `import {type T}`, we do not emit an import and instead push any\n                            if (resolved.typeOnly) {\n                                program.pushOp(ReflectionOp.any);\n                                return;\n                            }\n\n                            // //check if the referenced declaration has reflection disabled\n                            const declarationReflection = this.findReflectionConfig(declaration, program);\n                            if (declarationReflection.mode === 'never') {\n                                program.pushOp(ReflectionOp.any);\n                                return;\n                            }\n\n                            const found = this.resolver.resolve(this.sourceFile, resolved.importDeclaration);\n                            if (!found) {\n                                debug('module not found');\n                                program.pushOp(ReflectionOp.any);\n                                return;\n                            }\n\n                            // check if this is a viable option:\n                            // //check if the referenced file has reflection info emitted. if not, any is emitted for that reference\n                            // const typeVar = this.getDeclarationVariableName(typeName);\n                            // //check if typeVar is exported in referenced file\n                            // const builtType = isNodeWithLocals(found) && found.locals && found.locals.has(typeVar.escapedText);\n                            // if (!builtType) {\n                            //     program.pushOp(ReflectionOp.any);\n                            //     return;\n                            // }\n\n                            //check if the referenced file has reflection info emitted. if not, any is emitted for that reference\n                            const reflection = this.findReflectionFromPath(found.fileName);\n                            if (reflection.mode === 'never') {\n                                program.pushOp(ReflectionOp.any);\n                                return;\n                            }\n\n                            // this.addImports.push({ identifier: typeVar, from: resolved.importDeclaration.moduleSpecifier });\n                            this.addImports.push({ identifier: this.getDeclarationVariableName(typeName), from: resolved.importDeclaration.moduleSpecifier });\n                        }\n                    } else {\n                        //it's a reference type inside the same file. Make sure its type is reflected\n                        const reflection = this.findReflectionConfig(declaration, program);\n                        if (reflection.mode === 'never') {\n                            program.pushOp(ReflectionOp.any);\n                            return;\n                        }\n\n                        this.compileDeclarations.set(declaration, {\n                            name: typeName,\n                            sourceFile: declarationSourceFile,\n                        });\n                    }\n                }\n\n                const index = program.pushStack(program.forNode === declaration ? 0 : this.f.createArrowFunction(undefined, undefined, [], undefined, undefined, this.getDeclarationVariableName(typeName)));\n                if (type.typeArguments) {\n                    for (const argument of type.typeArguments) {\n                        this.extractPackStructOfType(argument, program);\n                    }\n                    program.pushOp(ReflectionOp.inlineCall, index, type.typeArguments.length);\n                } else {\n                    program.pushOp(ReflectionOp.inline, index);\n                }\n\n                // if (type.typeArguments) {\n                //     for (const argument of type.typeArguments) {\n                //         this.extractPackStructOfType(argument, program);\n                //     }\n                //     program.pushOp(ReflectionOp.inlineCall, index, type.typeArguments.length);\n                // } else {\n                //     program.pushOp(ReflectionOp.inline, index);\n                // }\n                // } else if (isTypeLiteralNode(declaration)) {\n                //     this.extractPackStructOfType(declaration, program);\n                //     return;\n                // } else if (isMappedTypeNode(declaration)) {\n                //     //<Type>{[Property in keyof Type]: boolean;};\n                //     this.extractPackStructOfType(declaration, program);\n                //     return;\n            } else if (isClassDeclaration(declaration) || isFunctionDeclaration(declaration) || isFunctionExpression(declaration) || isArrowFunction(declaration)) {\n                //if explicit `import {type T}`, we do not emit an import and instead push any\n                if (resolved.typeOnly) {\n                    program.pushOp(ReflectionOp.any);\n                    return;\n                }\n\n                if (resolved.importDeclaration && isIdentifier(typeName)) ensureImportIsEmitted(resolved.importDeclaration, typeName);\n                program.pushFrame();\n                if (type.typeArguments) {\n                    for (const typeArgument of type.typeArguments) {\n                        this.extractPackStructOfType(typeArgument, program);\n                    }\n                }\n                const body = isIdentifier(typeName) ? typeName : this.createAccessorForEntityName(typeName);\n                const index = program.pushStack(this.f.createArrowFunction(undefined, undefined, [], undefined, undefined, body));\n                program.pushOp(isClassDeclaration(declaration) ? ReflectionOp.classReference : ReflectionOp.functionReference, index);\n                program.popFrameImplicit();\n            } else if (isTypeParameterDeclaration(declaration)) {\n                this.resolveTypeParameter(declaration, type, program);\n            } else {\n                this.extractPackStructOfType(declaration, program);\n            }\n        }\n    }\n\n    /**\n     * Returns the class declaration, function/arrow declaration, or block where type was used.\n     */\n    protected getTypeUser(type: Node): Node {\n        let current: Node = type;\n        while (current) {\n            if (current.kind === SyntaxKind.Block) return current; //return the block\n            if (current.kind === SyntaxKind.ClassDeclaration) return current; //return the class\n            if (current.kind === SyntaxKind.ClassExpression) return current; //return the class\n            if (current.kind === SyntaxKind.Constructor) return current.parent; //return the class\n            if (current.kind === SyntaxKind.MethodDeclaration) return current.parent; //return the class\n            if (current.kind === SyntaxKind.ArrowFunction || current.kind === SyntaxKind.FunctionDeclaration || current.kind === SyntaxKind.FunctionExpression) return current;\n\n            current = current.parent;\n        }\n        return current;\n    }\n\n    /**\n     * With this function we want to check if `type` is used in the signature itself from the parent of `declaration`.\n     * If so, we do not try to infer the type from runtime values.\n     *\n     * Examples where we do not infer from runtime, `type` being `T` and `declaration` being `<T>` (return false):\n     *\n     * ```typescript\n     * class User<T> {\n     *     config: T;\n     * }\n     *\n     * class User<T> {\n     *    constructor(public config: T) {}\n     * }\n     *\n     * function do<T>(item: T): void {}\n     * function do<T>(item: T): T {}\n     * ```\n     *\n     * Examples where we infer from runtime (return true):\n     *\n     * ```typescript\n     * function do<T>(item: T) {\n     *     return typeOf<T>; //<-- because of that\n     * }\n     *\n     * function do<T>(item: T) {\n     *     class A {\n     *         config: T; //<-- because of that\n     *     }\n     *     return A;\n     * }\n     *\n     * function do<T>(item: T) {\n     *     class A {\n     *         doIt() {\n     *             class B {\n     *                 config: T; //<-- because of that\n     *             }\n     *             return B;\n     *         }\n     *     }\n     *     return A;\n     * }\n     *\n     * function do<T>(item: T) {\n     *     class A {\n     *         doIt(): T { //<-- because of that\n     *         }\n     *     }\n     *     return A;\n     * }\n     * ```\n     */\n    protected needsToBeInferred(declaration: TypeParameterDeclaration, type: TypeReferenceNode | ExpressionWithTypeArguments): boolean {\n        const declarationUser = this.getTypeUser(declaration);\n        const typeUser = this.getTypeUser(type);\n\n        return declarationUser !== typeUser;\n    }\n\n    protected resolveTypeParameter(declaration: TypeParameterDeclaration, type: TypeReferenceNode | ExpressionWithTypeArguments, program: CompilerProgram) {\n        //check if `type` was used in an expression. if so, we need to resolve it from runtime, otherwise we mark it as T\n        const isUsedInFunction = isFunctionLike(declaration.parent);\n        const resolveRuntimeTypeParameter = (isUsedInFunction && program.isResolveFunctionParameters(declaration.parent)) || (this.needsToBeInferred(declaration, type));\n\n        if (resolveRuntimeTypeParameter) {\n            //go through all parameters and look where `type.name.escapedText` is used (recursively).\n            //go through all found parameters and replace `T` with `infer T` and embed its type in `typeof parameter extends Type<infer T> ? T : never`, if T is not directly used\n            const argumentName = declaration.name.escapedText as string; //T\n            const foundUsers: { type: Node, parameterName: Identifier }[] = [];\n\n            if (isUsedInFunction) {\n                for (const parameter of (declaration.parent as SignatureDeclaration).parameters) {\n                    if (!parameter.type) continue;\n                    //if deeply available?\n                    let found = false;\n                    const searchArgument = (node: Node): Node => {\n                        node = visitEachChild(node, searchArgument, this.context);\n\n                        if (isIdentifier(node) && node.escapedText === argumentName) {\n                            //transform to infer T\n                            found = true;\n                            node = this.f.createInferTypeNode(declaration);\n                        }\n\n                        return node;\n                    };\n\n                    const updatedParameterType = visitEachChild(parameter.type, searchArgument, this.context);\n                    if (found && isIdentifier(parameter.name)) {\n                        foundUsers.push({ type: updatedParameterType, parameterName: parameter.name });\n                    }\n                }\n            }\n\n            if (foundUsers.length) {\n                //todo: if there are multiple infers, we need to create an intersection\n                if (foundUsers.length > 1) {\n                    //todo: intersection start\n                }\n\n                for (const foundUser of foundUsers) {\n                    program.pushConditionalFrame();\n\n                    program.pushOp(ReflectionOp.typeof, program.pushStack(this.f.createArrowFunction(undefined, undefined, [], undefined, undefined, foundUser.parameterName)));\n                    this.extractPackStructOfType(foundUser.type, program);\n                    program.pushOp(ReflectionOp.extends);\n\n                    const found = program.findVariable(getIdentifierName(declaration.name));\n                    if (found) {\n                        this.extractPackStructOfType(declaration.name, program);\n                    } else {\n                        //type parameter was never found in X of `Y extends X` (no `infer X` was created), probably due to a not supported parameter type expression.\n                        program.pushOp(ReflectionOp.any);\n                    }\n                    this.extractPackStructOfType({ kind: SyntaxKind.NeverKeyword } as TypeNode, program);\n                    program.pushOp(ReflectionOp.condition);\n                    program.popFrameImplicit();\n                }\n\n                if (foundUsers.length > 1) {\n                    //todo: intersection end\n                }\n\n            } else if (declaration.constraint) {\n                if (isUsedInFunction) program.resolveFunctionParametersIncrease(declaration.parent);\n                const constraint = getEffectiveConstraintOfTypeParameter(declaration);\n                if (constraint) {\n                    this.extractPackStructOfType(constraint, program);\n                } else {\n                    program.pushOp(ReflectionOp.never);\n                }\n                if (isUsedInFunction) program.resolveFunctionParametersDecrease(declaration.parent);\n            } else {\n                program.pushOp(ReflectionOp.never);\n            }\n        } else {\n            program.pushOp(ReflectionOp.any);\n            // program.pushOp(ReflectionOp.typeParameter, program.findOrAddStackEntry(getNameAsString(typeName)));\n        }\n    }\n\n    protected createAccessorForEntityName(e: QualifiedName): PropertyAccessExpression {\n        return this.f.createPropertyAccessExpression(isIdentifier(e.left) ? e.left : this.createAccessorForEntityName(e.left), e.right);\n    }\n\n    protected findDeclarationInFile(sourceFile: SourceFile | ModuleDeclaration, declarationName: __String): Declaration | undefined {\n        if (isNodeWithLocals(sourceFile) && sourceFile.locals) {\n            const declarationSymbol = sourceFile.locals.get(declarationName);\n            if (declarationSymbol && declarationSymbol.declarations && declarationSymbol.declarations[0]) {\n                return declarationSymbol.declarations[0];\n            }\n        }\n        return;\n    }\n\n    protected resolveImportSpecifier(declarationName: __String, importOrExport: ExportDeclaration | ImportDeclaration, sourceFile: SourceFile): Declaration | undefined {\n        if (!importOrExport.moduleSpecifier) return;\n        if (!isStringLiteral(importOrExport.moduleSpecifier)) return;\n\n        let source: SourceFile | ModuleDeclaration | undefined = this.resolver.resolve(sourceFile, importOrExport);\n\n        if (!source) {\n            debug('module not found', (importOrExport.moduleSpecifier as any).text, 'Is transpileOnly enabled? It needs to be disabled.');\n            return;\n        }\n\n        const declaration = this.findDeclarationInFile(source, declarationName);\n\n        /**\n         * declaration could also be `import {PrimaryKey} from 'xy'`, which we want to skip\n         */\n        if (declaration && !isImportSpecifier(declaration)) {\n            //if `export {PrimaryKey} from 'xy'`, then follow xy\n            if (isExportDeclaration(declaration)) {\n                return this.followExport(declarationName, declaration, source);\n            }\n            return declaration;\n        }\n\n        //not found, look in exports\n        if (isSourceFile(source)) {\n            for (const statement of source.statements) {\n                if (!isExportDeclaration(statement)) continue;\n                const found = this.followExport(declarationName, statement, source);\n                if (found) return found;\n            }\n        }\n\n        return;\n    }\n\n    protected followExport(declarationName: __String, statement: ExportDeclaration, sourceFile: SourceFile): Declaration | undefined {\n        if (statement.exportClause) {\n            //export {y} from 'x'\n            if (isNamedExports(statement.exportClause)) {\n                for (const element of statement.exportClause.elements) {\n                    //see if declarationName is exported\n                    if (element.name.escapedText === declarationName) {\n                        const found = this.resolveImportSpecifier(element.propertyName ? element.propertyName.escapedText : declarationName, statement, sourceFile);\n                        if (found) return found;\n                    }\n                }\n            }\n        } else {\n            //export * from 'x'\n            //see if `x` exports declarationName (or one of its exports * from 'y')\n            const found = this.resolveImportSpecifier(declarationName, statement, sourceFile);\n            if (found) {\n                return found;\n            }\n        }\n        return;\n    }\n\n    protected getTypeOfType(type: Node | Declaration): Expression | undefined {\n        const reflection = this.findReflectionConfig(type);\n        if (reflection.mode === 'never') return;\n\n        const program = new CompilerProgram(type, this.sourceFile);\n        this.extractPackStructOfType(type, program);\n        return this.packOpsAndStack(program);\n    }\n\n    protected packOpsAndStack(program: CompilerProgram) {\n        const packStruct = program.buildPackStruct();\n        if (packStruct.ops.length === 0) return;\n        // debugPackStruct(this.sourceFile, program.forNode, packStruct);\n        const packed = [...packStruct.stack, encodeOps(packStruct.ops)];\n        return this.valueToExpression(packed);\n    }\n\n    /**\n     * Note: We have to duplicate the expressions as it can be that incoming expression are from another file and contain wrong pos/end properties,\n     * so the code generation is then broken when we simply reuse them. Wrong code like ``User.__type = [.toEqual({`` is then generated.\n     * This function is probably not complete, but we add new copies when required.\n     */\n    protected valueToExpression(value: undefined | PackExpression | PackExpression[]): Expression {\n        return this.nodeConverter.toExpression(value);\n    }\n\n    /**\n     * A class is decorated with type information by adding a static variable.\n     *\n     * class Model {\n     *     static __types = pack(ReflectionOp.string); //<-- encoded type information\n     *     title: string;\n     * }\n     */\n    protected decorateClass(node: ClassDeclaration | ClassExpression): Node {\n        const reflection = this.findReflectionConfig(node);\n        if (reflection.mode === 'never') {\n            return node;\n        }\n        const type = this.getTypeOfType(node);\n        const __type = this.f.createPropertyDeclaration(this.f.createModifiersFromModifierFlags(ModifierFlags.Static), '__type', undefined, undefined, type);\n        if (isClassDeclaration(node)) {\n            // return node;\n            return this.f.updateClassDeclaration(node, node.modifiers,\n                node.name, node.typeParameters, node.heritageClauses,\n                this.f.createNodeArray<ClassElement>([...node.members, __type])\n            );\n        }\n\n        return this.f.updateClassExpression(node, node.modifiers,\n            node.name, node.typeParameters, node.heritageClauses,\n            this.f.createNodeArray<ClassElement>([...node.members, __type])\n        );\n    }\n\n    /**\n     * const fn = function() {}\n     *\n     * => const fn = __assignType(function() {}, [34])\n     */\n    protected decorateFunctionExpression(expression: FunctionExpression) {\n        const encodedType = this.getTypeOfType(expression);\n        if (!encodedType) return expression;\n\n        return this.wrapWithAssignType(expression, encodedType);\n    }\n\n    /**\n     * function name() {}\n     *\n     * => function name() {}; name.__type = 34;\n     */\n    protected decorateFunctionDeclaration(declaration: FunctionDeclaration) {\n\n        const encodedType = this.getTypeOfType(declaration);\n        if (!encodedType) return declaration;\n\n        if (!declaration.name) {\n            //its likely `export default function() {}`\n            if (!declaration.body) return;\n\n            //since a new default export is created, we do not need ExportKey&DefaultKeyword on the function anymore,\n            //but it should preserve all others like Async.\n            const modifier = declaration.modifiers ? declaration.modifiers.filter(v => v.kind !== SyntaxKind.ExportKeyword && v.kind !== SyntaxKind.DefaultKeyword) : [];\n            return this.f.createExportAssignment(undefined, undefined, this.wrapWithAssignType(\n                this.f.createFunctionExpression(modifier, declaration.asteriskToken, declaration.name, declaration.typeParameters, declaration.parameters, declaration.type, declaration.body),\n                encodedType\n            ));\n        }\n\n        const statements: Statement[] = [declaration];\n        statements.push(this.f.createExpressionStatement(\n            this.f.createAssignment(this.f.createPropertyAccessExpression(serializeEntityNameAsExpression(this.f, declaration.name), '__type'), encodedType)\n        ));\n        return statements;\n    }\n\n    /**\n     * const fn = () => { }\n     * => const fn = Object.assign(() => {}, {__type: 34})\n     */\n    protected decorateArrow(expression: ArrowFunction) {\n        const encodedType = this.getTypeOfType(expression);\n        if (!encodedType) return expression;\n\n        return this.wrapWithAssignType(expression, encodedType);\n    }\n\n    /**\n     * Object.assign(fn, {__type: []}) is much slower than a custom implementation like\n     *\n     * assignType(fn, [])\n     *\n     * where we embed assignType() at the beginning of the type.\n     */\n    protected wrapWithAssignType(fn: Expression, type: Expression) {\n        this.embedAssignType = true;\n\n        return this.f.createCallExpression(\n            this.f.createIdentifier('__assignType'),\n            undefined,\n            [\n                fn,\n                type\n            ]\n        );\n    }\n\n    protected parseReflectionMode(mode: typeof reflectionModes[number] | '' | boolean | string | string[] | undefined, configPathDir: string): typeof reflectionModes[number] {\n        if (Array.isArray(mode)) {\n            if (!configPathDir) return 'never';\n            const matches = contains(this.sourceFile.fileName, mode, {\n                cwd: configPathDir\n            });\n\n            return matches ? 'default' : 'never';\n        }\n        if ('boolean' === typeof mode) return mode ? 'default' : 'never';\n        if (mode === 'default' || mode === 'always') return mode;\n        return 'never';\n    }\n\n    protected resolvedTsConfig: { [path: string]: { data: Record<string, any>, exists: boolean } } = {};\n    protected resolvedPackageJson: { [path: string]: { data: Record<string, any>, exists: boolean } } = {};\n\n    protected parseReflectionOptionsDefaults(options: ReflectionOptions) {\n        options = isObject(options) ? options : {};\n        if (!options.exclude) options.exclude = this.defaultExcluded;\n        return options;\n    }\n\n    protected findReflectionConfig(node: Node, program?: CompilerProgram): ReflectionConfig {\n        if (program && program.sourceFile.fileName !== this.sourceFile.fileName) {\n            //when the node is from another module it was already decided that it will be reflected, so\n            //make sure it returns correct mode. for globals this would read otherwise to `mode: never`.\n            return { mode: 'always', options: this.parseReflectionOptionsDefaults({}) };\n        }\n\n        let current: Node | undefined = node;\n        let reflection: typeof reflectionModes[number] | undefined;\n\n        do {\n            const tags = getJSDocTags(current);\n            for (const tag of tags) {\n                if (!reflection && getIdentifierName(tag.tagName) === 'reflection' && 'string' === typeof tag.comment) {\n                    return { mode: this.parseReflectionMode(tag.comment as any || true, ''), options: this.parseReflectionOptionsDefaults({}) };\n                }\n            }\n            current = current.parent;\n        } while (current);\n\n        //nothing found, look in tsconfig.json\n        if (this.reflectionMode !== undefined) return { mode: this.reflectionMode, options: this.parseReflectionOptionsDefaults(this.reflectionOptions || {}) };\n\n        if (!serverEnv) {\n            return { mode: 'default', options: this.parseReflectionOptionsDefaults({}) };\n        }\n\n        if (program && program.sourceFile.fileName === this.sourceFile.fileName) {\n            //if the node is from the same module as we currently process, we use the loaded reflection options set early in transformSourceFile().\n            return { mode: this.reflectionMode || 'never', options: this.parseReflectionOptionsDefaults(this.reflectionOptions || {}) };\n        }\n\n        const sourceFile = findSourceFile(node) || this.sourceFile;\n        return this.findReflectionFromPath(sourceFile.fileName);\n    }\n\n    protected readJson(path: string): Record<string, any> | undefined {\n        try {\n            let content = readFileSync(path, 'utf8');\n            content = stripJsonComments(content);\n            return JSON.parse(content);\n        } catch (error) {\n            console.warn(`Could not parse ${path}: ${error}`);\n        }\n        return undefined;\n    }\n\n    protected findReflectionFromPath(path: string): ReflectionConfig {\n        if (!serverEnv) {\n            return { mode: 'default', options: this.parseReflectionOptionsDefaults({}) };\n        }\n\n        let currentDir = dirname(path);\n        let reflection: typeof reflectionModes[number] | undefined;\n\n        while (currentDir) {\n            const packageJsonPath = join(currentDir, 'package.json');\n            const tsConfigPath = join(currentDir, 'tsconfig.json');\n\n            let packageJson: Record<string, any> = {};\n            let tsConfig: Record<string, any> = {};\n\n            const packageJsonCache = this.resolvedPackageJson[packageJsonPath];\n            let packageJsonExists = false;\n\n            if (packageJsonCache) {\n                packageJson = packageJsonCache.data;\n                packageJsonExists = packageJsonCache.exists;\n            } else {\n                packageJsonExists = existsSync(packageJsonPath);\n                this.resolvedPackageJson[packageJsonPath] = { exists: packageJsonExists, data: {} };\n                if (packageJsonExists) {\n                    try {\n                        let content = readFileSync(packageJsonPath, 'utf8');\n                        content = stripJsonComments(content);\n                        packageJson = JSON.parse(content);\n                        this.resolvedPackageJson[packageJsonPath].data = packageJson;\n                    } catch (error: any) {\n                        console.warn(`Could not parse ${packageJsonPath}: ${error}`);\n                    }\n                }\n            }\n\n            const tsConfigCache = this.resolvedTsConfig[tsConfigPath];\n            let tsConfigExists = false;\n\n            if (tsConfigCache) {\n                tsConfig = tsConfigCache.data;\n                tsConfigExists = tsConfigCache.exists;\n            } else {\n                tsConfigExists = existsSync(tsConfigPath);\n                this.resolvedTsConfig[tsConfigPath] = { exists: tsConfigExists, data: {} };\n                if (tsConfigExists) {\n                    try {\n                        tsConfig = this.readJson(tsConfigPath) || {};\n                        // resolve extends recursively\n                        let dir = currentDir;\n                        while (tsConfig.extends) {\n                            const file = isAbsolute(tsConfig.extends) ? tsConfig.extends : join(dir, tsConfig.extends);\n                            const ext = this.readJson(file) || {};\n                            delete tsConfig.extends;\n                            tsConfig = Object.assign(ext, tsConfig);\n                            dir = dirname(file);\n                        }\n                        this.resolvedTsConfig[tsConfigPath].data = tsConfig;\n                    } catch (error: any) {\n                        console.warn(`Could not parse ${tsConfigPath}: ${error}`);\n                    }\n                }\n            }\n\n            if (reflection === undefined && packageJson.reflection !== undefined) {\n                return {\n                    mode: this.parseReflectionMode(packageJson.reflection, currentDir),\n                    baseDir: currentDir,\n                    options: this.parseReflectionOptionsDefaults(packageJson.reflectionOptions || {})\n                };\n            }\n\n            if (reflection === undefined && tsConfig.reflection !== undefined) {\n                return {\n                    mode: this.parseReflectionMode(tsConfig.reflection, currentDir),\n                    baseDir: currentDir,\n                    options: this.parseReflectionOptionsDefaults(tsConfig.reflectionOptions || {})\n                };\n            }\n\n            if (packageJsonExists) {\n                //we end the search at package.json so that package in node_modules without reflection option\n                //do not inherit the tsconfig from the project.\n                break;\n            }\n\n            const next = join(currentDir, '..');\n            if (resolve(next) === resolve(currentDir)) break; //we are at root\n            currentDir = next;\n        }\n\n        return { mode: reflection || 'never', options: this.parseReflectionOptionsDefaults({}) };\n    }\n}\n\nexport class DeclarationTransformer extends ReflectionTransformer {\n\n    protected addExports: { identifier: string }[] = [];\n\n    transformSourceFile(sourceFile: SourceFile): SourceFile {\n        if ((sourceFile as any).deepkitDeclarationTransformed) return sourceFile;\n        (sourceFile as any).deepkitDeclarationTransformed = true;\n\n        this.sourceFile = sourceFile;\n        this.addExports = [];\n\n        const reflection = this.findReflectionConfig(sourceFile);\n        if (reflection.mode === 'never') {\n            return sourceFile;\n        }\n\n        const visitor = (node: Node): any => {\n            node = visitEachChild(node, visitor, this.context);\n\n            if ((isTypeAliasDeclaration(node) || isInterfaceDeclaration(node)) && hasModifier(node, SyntaxKind.ExportKeyword)) {\n                const reflection = this.findReflectionConfig((node as any).original || node); //original needed here since TS does not emit jsDoc in the declaration transformer. I don't know why.\n                if (reflection.mode !== 'never') {\n                    this.addExports.push({ identifier: getIdentifierName(this.getDeclarationVariableName(node.name)) });\n                }\n            }\n\n            return node;\n        };\n        this.sourceFile = visitNode(this.sourceFile, visitor);\n\n        if (this.addExports.length) {\n            const exports: Statement[] = [];\n            const handledIdentifier: string[] = [];\n            for (const imp of this.addExports) {\n                if (handledIdentifier.includes(imp.identifier)) continue;\n                handledIdentifier.push(imp.identifier);\n\n                //export declare type __ΩXY = any[];\n                exports.push(this.f.createTypeAliasDeclaration([\n                        this.f.createModifier(SyntaxKind.ExportKeyword),\n                        this.f.createModifier(SyntaxKind.DeclareKeyword)\n                    ], this.f.createIdentifier(imp.identifier),\n                    undefined,\n                    this.f.createArrayTypeNode(this.f.createKeywordTypeNode(SyntaxKind.AnyKeyword))\n                ));\n            }\n\n            this.sourceFile = this.f.updateSourceFile(this.sourceFile, [...this.sourceFile.statements, ...exports]);\n        }\n\n        return this.sourceFile;\n    }\n}\n\nlet loaded = false;\n\nexport const transformer: CustomTransformerFactory | TransformerFactory<SourceFile> = function deepkitTransformer(context) {\n    if (!loaded) {\n        debug('@deepkit/type transformer loaded\\n');\n        loaded = true;\n    }\n    return new ReflectionTransformer(context);\n};\n\nexport const declarationTransformer: CustomTransformerFactory | TransformerFactory<SourceFile> = function deepkitDeclarationTransformer(context) {\n    return new DeclarationTransformer(context);\n};\n\n","/*\n * Deepkit Framework\n * Copyright (c) Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nimport type {\n    ArrowFunction,\n    BigIntLiteral,\n    BinaryExpression,\n    ComputedPropertyName,\n    EntityName,\n    Expression,\n    Identifier,\n    ImportDeclaration,\n    JSDoc,\n    ModifierLike,\n    Node,\n    NodeArray,\n    NodeFactory,\n    NumericLiteral,\n    PrivateIdentifier,\n    PropertyAccessExpression,\n    QualifiedName,\n    StringLiteral,\n    StringLiteralLike,\n    SymbolTable,\n} from 'typescript';\nimport ts from 'typescript';\nimport { cloneNode as tsNodeClone, CloneNodeHook } from '@marcj/ts-clone-node';\nimport { SourceFile } from './ts-types.js';\n\nconst {\n    isArrowFunction,\n    isComputedPropertyName,\n    isIdentifier,\n    isNamedImports,\n    isNumericLiteral,\n    isPrivateIdentifier,\n    isStringLiteral,\n    isStringLiteralLike,\n    setOriginalNode,\n    NodeFlags,\n    SyntaxKind\n} = ts;\n\nexport type PackExpression = Expression | string | number | boolean | bigint;\n\nexport function getIdentifierName(node: Identifier | PrivateIdentifier): string {\n    return ts.unescapeLeadingUnderscores(node.escapedText);\n}\n\nexport function joinQualifiedName(name: EntityName): string {\n    if (isIdentifier(name)) return getIdentifierName(name);\n    return joinQualifiedName(name.left) + '_' + getIdentifierName(name.right);\n}\n\nfunction hasJsDoc(node: any): node is { jsDoc: JSDoc[]; } {\n    return 'jsDoc' in node && !!(node as any).jsDoc;\n}\n\nexport function extractJSDocAttribute(node: Node, attribute: string): string {\n    if (!hasJsDoc(node)) return '';\n\n    for (const doc of node.jsDoc) {\n        if (!doc.tags) continue;\n        for (const tag of doc.tags) {\n            if (getIdentifierName(tag.tagName) === attribute && 'string' === typeof tag.comment) return tag.comment;\n        }\n    }\n\n    return '';\n}\n\nexport function getPropertyName(f: NodeFactory, node?: Identifier | StringLiteral | NumericLiteral | ComputedPropertyName | PrivateIdentifier): string | symbol | number | ArrowFunction {\n    if (!node) return '';\n\n    if (isIdentifier(node)) return getIdentifierName(node);\n    if (isStringLiteral(node)) return node.text;\n    if (isNumericLiteral(node)) return +node.text;\n    if (isComputedPropertyName(node)) {\n        return f.createArrowFunction(undefined, undefined, [], undefined, undefined, node.expression);\n    }\n    if (isPrivateIdentifier(node)) return getIdentifierName(node);\n\n    return '';\n}\n\nexport function getNameAsString(node?: Identifier | StringLiteral | NumericLiteral | ComputedPropertyName | PrivateIdentifier | QualifiedName): string {\n    if (!node) return '';\n    if (isIdentifier(node)) return getIdentifierName(node);\n    if (isStringLiteral(node)) return node.text;\n    if (isNumericLiteral(node)) return node.text;\n    if (isComputedPropertyName(node)) {\n        if (isStringLiteralLike(node) || isNumericLiteral(node)) return (node as StringLiteralLike | NumericLiteral).text;\n        return '';\n    }\n    if (isPrivateIdentifier(node)) return getIdentifierName(node);\n\n    return joinQualifiedName(node);\n}\n\nexport function hasModifier(node: { modifiers?: NodeArray<ModifierLike> }, modifier: ts.SyntaxKind): boolean {\n    if (!node.modifiers) return false;\n    return node.modifiers.some(v => v.kind === modifier);\n}\n\nconst cloneHook = <T extends Node>(node: T, payload: { depth: number }): CloneNodeHook<T> | undefined => {\n    if (isIdentifier(node)) {\n        //ts-clone-node wants to read `node.text` which does not exist. we hook into it and provide the correct value.\n        return {\n            text: () => {\n                return getIdentifierName(node);\n            }\n        } as any;\n    }\n    return;\n};\n\nexport class NodeConverter {\n    constructor(protected f: NodeFactory) {\n    }\n\n    toExpression<T extends PackExpression | PackExpression[]>(node?: T): Expression {\n        if (node === undefined) return this.f.createIdentifier('undefined');\n\n        if (Array.isArray(node)) {\n            return this.f.createArrayLiteralExpression(this.f.createNodeArray(node.map(v => this.toExpression(v))) as NodeArray<Expression>);\n        }\n\n        if ('string' === typeof node) return this.f.createStringLiteral(node, true);\n        if ('number' === typeof node) return this.f.createNumericLiteral(node);\n        if ('bigint' === typeof node) return this.f.createBigIntLiteral(String(node));\n        if ('boolean' === typeof node) return node ? this.f.createTrue() : this.f.createFalse();\n\n        if (node.pos === -1 && node.end === -1 && node.parent === undefined) {\n            if (isArrowFunction(node)) {\n                if (node.body.pos === -1 && node.body.end === -1 && node.body.parent === undefined) return node;\n                return this.f.createArrowFunction(node.modifiers, node.typeParameters, node.parameters, node.type, node.equalsGreaterThanToken, this.toExpression(node.body as Expression));\n            }\n            return node;\n        }\n        switch (node.kind) {\n            case SyntaxKind.Identifier:\n                return finish(node, this.f.createIdentifier(getIdentifierName(node as Identifier)));\n            case SyntaxKind.StringLiteral:\n                return finish(node, this.f.createStringLiteral((node as StringLiteral).text));\n            case SyntaxKind.NumericLiteral:\n                return finish(node, this.f.createNumericLiteral((node as NumericLiteral).text));\n            case SyntaxKind.BigIntLiteral:\n                return finish(node, this.f.createBigIntLiteral((node as BigIntLiteral).text));\n            case SyntaxKind.TrueKeyword:\n                return finish(node, this.f.createTrue());\n            case SyntaxKind.FalseKeyword:\n                return finish(node, this.f.createFalse());\n        }\n\n        //todo: ts-node-clone broke with ts 4.8,\n        // => TypeError: Cannot read properties of undefined (reading 'emitNode')\n        // which is probably due a broken node clone. We need to figure out which node it is\n        // and see what the issue is. since ts-node-clone is not really maintained anymore,\n        // we need to fork it\n        try {\n            return tsNodeClone(node, {\n                preserveComments: false,\n                factory: this.f,\n                setOriginalNodes: true,\n                preserveSymbols: true,\n                setParents: true,\n                hook: cloneHook\n            }) as Expression;\n        } catch (error) {\n            console.error('could not clone node', node);\n            throw error;\n        }\n\n    }\n}\n\nfunction isExternalOrCommonJsModule(file: SourceFile): boolean {\n    //both attributes are internal and not yet public\n    return (file.externalModuleIndicator || file.commonJsModuleIndicator) !== undefined;\n}\n\nexport function isNodeWithLocals(node: Node): node is (Node & { locals: SymbolTable | undefined }) {\n    return 'locals' in node;\n}\n\n//logic copied from typescript\nexport function getGlobalsOfSourceFile(file: SourceFile): SymbolTable | void {\n    if (file.redirectInfo) return;\n    if (!isNodeWithLocals(file)) return;\n    if (!isExternalOrCommonJsModule(file)) return file.locals;\n    if (file.jsGlobalAugmentations) return file.jsGlobalAugmentations;\n    if (file.symbol && file.symbol.globalExports) return file.symbol.globalExports;\n}\n\n/**\n * For imports that can removed (like a class import only used as type only, like `p: Model[]`) we have\n * to modify the import so TS does not remove it.\n */\nexport function ensureImportIsEmitted(importDeclaration: ImportDeclaration, specifierName?: Identifier) {\n    if (specifierName && importDeclaration.importClause && importDeclaration.importClause.namedBindings) {\n        // const binding = importDeclaration.importClause.namedBindings;\n        if (isNamedImports(importDeclaration.importClause.namedBindings)) {\n            for (const element of importDeclaration.importClause.namedBindings.elements) {\n                if (element.name.escapedText === specifierName.escapedText) {\n                    (element.flags as any) |= NodeFlags.Synthesized;\n                    return;\n                }\n            }\n        }\n    }\n\n    (importDeclaration.flags as any) |= NodeFlags.Synthesized;\n}\n\n\n/**\n * Serializes an entity name as an expression for decorator type metadata.\n *\n * @param node The entity name to serialize.\n */\nexport function serializeEntityNameAsExpression(f: NodeFactory, node: EntityName): SerializedEntityNameAsExpression {\n    switch (node.kind) {\n        case SyntaxKind.Identifier:\n            return finish(node, f.createIdentifier(getIdentifierName(node)));\n        case SyntaxKind.QualifiedName:\n            return finish(node, serializeQualifiedNameAsExpression(f, node));\n    }\n    return node;\n}\n\ntype SerializedEntityNameAsExpression = Identifier | BinaryExpression | PropertyAccessExpression;\n\n/**\n * Serializes an qualified name as an expression for decorator type metadata.\n *\n * @param node The qualified name to serialize.\n * @param useFallback A value indicating whether to use logical operators to test for the\n *                    qualified name at runtime.\n */\nfunction serializeQualifiedNameAsExpression(f: NodeFactory, node: QualifiedName): SerializedEntityNameAsExpression {\n    return f.createPropertyAccessExpression(serializeEntityNameAsExpression(f, node.left), node.right);\n}\n\nexport type MetaNode = Node & {\n    jsDoc?: JSDoc[];\n    _original?: MetaNode;\n    original?: MetaNode;\n    _symbol?: Symbol;\n    symbol?: Symbol;\n    _parent?: MetaNode;\n    localSymbol?: Symbol;\n};\n\nfunction finish<T extends MetaNode>(oldNode: MetaNode, newNode: T): T {\n    setOriginalNode(newNode, oldNode);\n    newNode._original = newNode.original;\n\n    newNode._symbol = oldNode._symbol ?? oldNode.symbol;\n    newNode.symbol = newNode._symbol;\n    return newNode;\n}\n\n","/*\n * Deepkit Framework\n * Copyright (c) Deepkit UG, Marc J. Schmidt\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the MIT License.\n *\n * You should have received a copy of the MIT License along with this program.\n */\n\nexport const enum MappedModifier {\n    optional = 1 << 0,\n    removeOptional = 1 << 1,\n    readonly = 1 << 2,\n    removeReadonly = 1 << 3,\n}\n\n/**\n * note: Checks are based on range checks (>, <, etc), so when adding\n * new types a check is required for all code using `TypeNumberBrand`.\n */\nexport enum TypeNumberBrand {\n    integer,\n\n    int8,\n    int16,\n    int32,\n\n    uint8,\n    uint16,\n    uint32,\n\n    float,\n    float32,\n    float64,\n}\n\n/**\n * The instruction set.\n * Should not be greater than 93 members, because we encode it via charCode starting at 33. +93 means we end up with charCode=126\n * (which is '~' and the last char that can be represented without \\x. The next 127 is '\\x7F').\n */\nexport enum ReflectionOp {\n    never,\n    any,\n    unknown,\n    void,\n    object,\n\n    string,\n    number,\n    numberBrand,\n    boolean,\n    bigint,\n\n    symbol,\n    null,\n    undefined,\n\n    /**\n     * The literal type of string, number, or boolean.\n     *\n     * This OP has 1 parameter. The next byte is the absolute address of the literal on the stack, which is the actual literal value.\n     *\n     * Pushes a function type.\n     */\n    literal,\n\n    /**\n     * This OP pops all types on the current stack frame.\n     *\n     * This OP has 1 parameter. The next byte is the absolute address of a string|number|symbol entry on the stack.\n     *\n     * Pushes a function type.\n     */\n    function,\n\n    /**\n     * This OP pops all types on the current stack frame.\n     *\n     * Pushes a method type.\n     */\n    method,\n    methodSignature, //has 1 parameter, reference to stack for its property name\n\n    parameter,\n\n    /**\n     * This OP pops the latest type entry on the stack.\n     *\n     * Pushes a property type.\n     */\n    property,\n    propertySignature, //has 1 parameter, reference to stack for its property name\n\n    /**\n     * This OP pops all types on the current stack frame. Those types should be method|property.\n     *\n     * Pushes a TypeClass onto the stack.\n     */\n    class,\n\n    /**\n     * If a class extends another class with generics, this OP represents the generic type arguments of the super class.\n     *\n     * e.g. `class A extends B<string, boolean>`, string and boolean are on the stack and classExtends pops() them, and then assigns to A.extendsTypeArguments = [string, boolean].\n     *\n     * This is only emitted when the class that is currently being described actually extends another class and uses generics.\n     *\n     * This OP has 1 argument and pops x types from the stack. X is the first argument.\n     * Expects a TypeClass on the stack.\n     */\n    classExtends,\n\n    /**\n     * This OP has 1 parameter, the stack entry to the actual class symbol.\n     */\n    classReference,\n\n    /**\n     * Marks the last entry in the stack as optional. Used for method|property. Equal to the QuestionMark operator in a property assignment.\n     */\n    optional,\n    readonly,\n\n    //modifiers for property|method\n    public,\n    private,\n    protected,\n    abstract,\n    defaultValue,\n    description,\n    rest,\n\n    regexp,\n\n    enum,\n    enumMember, //has one argument, the name.\n\n    set,\n    map,\n\n    /**\n     * Pops the latest stack entry and uses it as T for an array type.\n     *\n     * Pushes an array type.\n     */\n    array,\n    tuple,\n    tupleMember,\n    namedTupleMember, //has one argument, the name.\n\n    union, //pops frame. requires frame start when stack can be dirty.\n    intersection,\n\n    indexSignature,\n    objectLiteral,\n    mappedType, //2 parameters: functionPointer and modifier.\n    in,\n\n    frame, //creates a new stack frame\n    moveFrame, //pop() as T, pops the current stack frame, push(T)\n    return,\n\n    templateLiteral,\n\n    //special instructions that exist to emit less output\n    date,\n\n    //those typed array OPs are here only to reduce runtime code overhead when used in types.\n    int8Array,\n    uint8ClampedArray,\n    uint8Array,\n    int16Array,\n    uint16Array,\n    int32Array,\n    uint32Array,\n    float32Array,\n    float64Array,\n    bigInt64Array,\n    arrayBuffer,\n\n    promise,\n\n    // pointer, //parameter is a number referencing an entry in the stack, relative to the very beginning (0). pushes that entry onto the stack.\n    arg, //@deprecated. parameter is a number referencing an entry in the stack, relative to the beginning of the current frame, *-1. pushes that entry onto the stack. this is related to the calling convention.\n    typeParameter, //generic type parameter, e.g. T in a generic. has 1 parameter: reference to the name.\n    typeParameterDefault, //generic type parameter with a default value, e.g. T in a generic. has 1 parameter: reference to the name. pop() for the default value\n    var, //reserve a new variable in the stack\n    loads, //pushes to the stack a referenced value in the stack. has 2 parameters: <frame> <index>, frame is a negative offset to the frame, and index the index of the stack entry withing the referenced frame\n\n    indexAccess, //T['string'], 2 items on the stack\n    keyof, //keyof operator\n    infer, //2 params, like `loads`\n    typeof, //1 parameter that points to a function returning the runtime value from which we need to extract the type\n\n    condition,\n    jumpCondition, //@deprecated. used when INFER is used in `extends` conditional branch. 2 args: left program, right program\n    jump, //jump to an address\n    call, //has one parameter, the next program address. creates a new stack frame with current program address as first stack entry, and jumps back to that + 1.\n    inline,\n    inlineCall,\n    distribute,//has one parameter, the co-routine program index.\n\n    extends, //X extends Y in a conditional type, XY popped from the stack, pushes boolean on the stack\n\n    widen, //widens the type on the stack, .e.g 'asd' => string, 34 => number, etc. this is necessary for infer runtime data, and widen if necessary (object member or non-contained literal)\n\n    static,\n    mappedType2, //same as mappedType2 but the given functionPointer returns a tuple [type, name]\n\n    functionReference, //Same as classReference but for functions\n\n    callSignature, //Same as function but for call signatures (in object literals)\n}\n","import type { CompilerHost, CompilerOptions, ExportDeclaration, Expression, ImportDeclaration, ResolvedModule, SourceFile, StringLiteral } from \"typescript\";\nimport ts from \"typescript\";\n\nconst { createSourceFile, resolveModuleName, SyntaxKind, ScriptTarget } = ts;\n\n/**\n * A utility to resolve a module path and its declaration.\n *\n * It automatically reads a SourceFile and binds it.\n */\nexport class Resolver {\n  protected sourceFiles: { [fileName: string]: SourceFile } = {};\n\n  constructor(public compilerOptions: CompilerOptions, public host: CompilerHost) {}\n\n  resolve(from: SourceFile, importOrExportNode: ExportDeclaration | ImportDeclaration): SourceFile | undefined {\n    const moduleSpecifier: Expression | undefined = importOrExportNode.moduleSpecifier;\n    if (!moduleSpecifier) return;\n    if (moduleSpecifier.kind !== SyntaxKind.StringLiteral) return;\n\n    return this.resolveSourceFile(from.fileName, (moduleSpecifier as StringLiteral).text);\n  }\n\n  resolveImpl(modulePath: string, fromPath: string): ResolvedModule | undefined {\n    if (this.host.resolveModuleNames !== undefined) {\n      return this.host.resolveModuleNames([modulePath], fromPath, /*reusedNames*/ undefined, /*redirectedReference*/ undefined, this.compilerOptions)[0];\n    }\n    const result = resolveModuleName(modulePath, fromPath, this.compilerOptions, this.host);\n    return result.resolvedModule;\n  }\n\n  /**\n   * Tries to resolve the d.ts file path for a given module path.\n   * Scans relative paths. Looks into package.json \"types\" and \"exports\" (with new 4.7 support)\n   *\n   * @param fromPath the path of the file that contains the import. modulePath is relative to that.\n   * @param modulePath the x in 'from x'.\n   */\n  resolveSourceFile(fromPath: string, modulePath: string): SourceFile | undefined {\n    const result = this.resolveImpl(modulePath, fromPath);\n    if (!result) return;\n\n    const fileName = result.resolvedFileName;\n    if (this.sourceFiles[fileName]) return this.sourceFiles[fileName];\n\n    const source = this.host.readFile(result.resolvedFileName);\n    if (!source) return;\n    const sourceFile = (this.sourceFiles[fileName] = createSourceFile(fileName, source, this.compilerOptions.target || ScriptTarget.ES2018, true));\n\n    //@ts-ignore\n    ts.bindSourceFile(sourceFile, this.compilerOptions);\n\n    return sourceFile;\n  }\n}\n"],"mappings":"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","names":["ts","ts","TypeNumberBrand","ts","SyntaxKind","isArrowFunction","isIdentifier","isStringLiteral","NodeFlags","SyntaxKind","ScriptTarget","ts","SyntaxKind","isIdentifier","path","ts","isArrowFunction","assignQ","NodeFlags","ScriptTarget","joinQualifiedName","resolved","isStringLiteral","reflection","ts"]}